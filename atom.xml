<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小李工作站</title>
  
  <subtitle>小李工作站</subtitle>
  <link href="https://lilongxin178.github.io/atom.xml" rel="self"/>
  
  <link href="https://lilongxin178.github.io/"/>
  <updated>2024-03-20T02:52:53.211Z</updated>
  <id>https://lilongxin178.github.io/</id>
  
  <author>
    <name>工程小李</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LDO工作原理简单探讨</title>
    <link href="https://lilongxin178.github.io/2024/01/20/LDO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8/"/>
    <id>https://lilongxin178.github.io/2024/01/20/LDO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8/</id>
    <published>2024-01-20T06:00:00.000Z</published>
    <updated>2024-03-20T02:52:53.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LDO工作原理简单探讨"><a href="#LDO工作原理简单探讨" class="headerlink" title="LDO工作原理简单探讨"></a>LDO工作原理简单探讨</h1><h2 id="一、LDO介绍"><a href="#一、LDO介绍" class="headerlink" title="一、LDO介绍"></a>一、LDO介绍</h2><p>​LDO英文名：low dropout regulator，低压差线性稳压器。<br>​电源的分类有很多种，比如<strong>开关电源</strong>、<strong>逆变电源</strong>、<strong>交流电源</strong>等等。在移动端消费类电子产品中，常用的有<strong>DCDC电源</strong>和<strong>LDO电源</strong>两种，DCDC的优点是效率高，但是噪声大；LDO正相反，它是效率低，噪声小。<br>​这两种电源具体在什么场景下使用不能一概而论，通常而言，对于噪声不太敏感的数字电路多可以优先考虑DCDC，而对于模拟电路，由于对噪声比较敏感，可以优先考虑LDO，但在大部分系统中，我们为了获得较好的电源效率以及稳定的电源系统，在进行设计时我们常常将两款电源系统进行混合使用。</p><h2 id="二、LDO模型及工作原理探讨"><a href="#二、LDO模型及工作原理探讨" class="headerlink" title="二、LDO模型及工作原理探讨"></a>二、LDO模型及工作原理探讨</h2><h3 id="先列举出我们可能较为常见的一些LDO模型"><a href="#先列举出我们可能较为常见的一些LDO模型" class="headerlink" title="先列举出我们可能较为常见的一些LDO模型"></a>先列举出我们可能较为常见的一些LDO模型</h3><p><strong>三极管型LDO：</strong><br><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319163743031.png" alt="三极管型LDO"></p><p><strong>PMOS型LDO：</strong><br><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/bccbaed39a891cee1fa2c4675802d51d.jpg" alt="NMOS型LDO"></p><p><strong>NMOS型LDO：</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/8ec246cee8ebb24437b130ac68e7a7ef.jpg" alt="PMOS型LDO"></p><p>​此时，我们发现三种结构大同小异，只有在管子的选择上略有不同，那么我们就将其分成两种结构（<strong>三极管结构、MOS管结构</strong>）进行分析。</p><h3 id="三极管型原理推导："><a href="#三极管型原理推导：" class="headerlink" title="三极管型原理推导："></a>三极管型原理推导：</h3><p>​我们对三极管型的结构进行剖析，首先，我们能看到由电阻R和二极管Dz组成的稳定电压源（Vref），以及R1、R2、R3组成的分压网络，以及RL所代表的输出负载电阻。那么此时三级管以及运放所组成的应该是什么呢？<br>​我们回到LDO的名字上，为什么要叫<strong>低压线性稳压器</strong>，那我在此先进行简单的猜测，暂且认为<strong>LDO</strong>是<strong>线性</strong>的一种元件（暂定）。<br>​那么运放在此处又是什么作用呢？有正有负，又没有反馈用的电阻，那么它是不是<strong>比较器</strong>呢，我们都知道运放开环使用就是比较器嘛。但是仔细想想，好像无法将此处的运放当作比较器来使用。运算放大器的开环增益普遍在80dB以上，并且我们在实际使用LDO时都知道我们的输出会有“纹波”，假设纹波5mV，经过分压网络后有2mV，此时运算放大器以80dB的开环增益计算，输出最高都可以达到20V。一般来说，哪怕运放输出电压轨足够高，可以令输出最高达到20V，但此时三极管或者MOS管在大部分时间是处于导通状态的，那导通了就与我们上面的假设背道而驰了，并且我们知道开关电源正因为管子做开关使用，在导通和截止两个状态变换，那此时这种状态显然也不是LDO该有的工作状态，那我就只能将运放用法进行变换。<br>​那我们给它加上反馈呢?加上反馈后，我们可以得到以下结构：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319162945677.png" alt="LDO误差放大器结构"></p><p>​此处反馈所使用的是复阻抗，具体为何下文在进行解释。<br>​当加入反馈后，运放便由比较器变成了误差放大器，那么此时我们就可以更简单的去分析LDO的原理了。再上一张图：</p><p>​<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319163637437.png" alt="三极管型LDO内部电流电压关系"></p><p>​由于运算放大器在开环增益足够大且具有负反馈电路的工作条件下，会具有虚短的特性，所以当误差放大器在系统稳定时，有：<br>$$<br>VFB&#x3D;Vref<br>$$<br>​此时，误差放大器有一稳定输出Vc&#x2F;Vb，此时三极管在Vb的作用下，有：<br>$$<br>Ie&#x3D;Ib*β<br>$$</p><h4 id="负载变化时，有两种情况："><a href="#负载变化时，有两种情况：" class="headerlink" title="负载变化时，有两种情况："></a>负载变化时，有两种情况：</h4><h5 id="1-当负载变大时"><a href="#1-当负载变大时" class="headerlink" title="1.当负载变大时"></a>1.当负载变大时</h5><p>​负载变大时，RL变小，此时由于电流IL不变，Vout随之下降，误差放大器同相反相之间产生误差，输出Vc+∆Vc,此时三极管基极电压增加，Ib增加，Ie增加，电流增加后，由于<br>$$<br>Vout&#x3D;RL*IL<br>$$<br>​所以，Vout会逐渐上升直到稳定到输出值</p><h5 id="2-当负载变小时"><a href="#2-当负载变小时" class="headerlink" title="2.当负载变小时"></a>2.当负载变小时</h5><p>​负载变小时，RL变大，此时由于电流IL不变，Vout随之上升，误差放大器同相反相之间产生误差，输出Vc-∆Vc,此时三极管基极电压下降，Ib减小，Ie减小，电流减小后，由于<br>$$<br>Vout&#x3D;RL*IL<br>$$<br>​所以，Vout会逐渐下降直到稳定到输出值</p><p>​<strong>负载变化调整输出的过程，也可以看作电路系统反馈稳定的过程，通过反馈环路的设计以达到一个稳定的输出环境。</strong></p><h4 id="三极管型LDO中三极管的工作区"><a href="#三极管型LDO中三极管的工作区" class="headerlink" title="三极管型LDO中三极管的工作区"></a>三极管型LDO中三极管的工作区</h4><p>​可以看到，在上述推导中进行了合理假设，并验证了假设的理论可能性。<br>​三极管在上述的探讨中，Ib与Ie始终具有着倍数关系，我们知道这种状态是三极管的放大区。<br>​以下是三极管的工作区特点，以及输出特性曲线，以便理解对比。</p><p><strong>(1)截止区：三极管工作在截止状态，当发射结电压Ube小于0.6—0.7V的导通电压，发射结没有导通集电结处于反向偏置，没有放大作用。</strong><br><strong>(2)放大区：三极管的发射极加正向电压，集电极加反向电压导通后，Ib控制Ic，Ic与Ib近似于线性关系，在基极加上一个小信号电流，引起集电极大的信号电流输出。</strong><br><strong>(3)饱和区：当三极管的集电结电流IC增大到一定程度时，再增大Ib，Ic也不会增大，超出了放大区，进入了饱和区。饱和时，Ic最大，集电极和发射之间的内阻最小，电压Uce只有0.1V~0.3V，Uce&lt;ube，发射结和集电结均处于正向电压。三极管没有放大作用，集电极和发射极相当于短路，常与截止配合于开关电路。</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319212529344.png" alt="三极管输出特性曲线"></p><h4 id="三级管型LDO简单仿真"><a href="#三级管型LDO简单仿真" class="headerlink" title="三级管型LDO简单仿真"></a>三级管型LDO简单仿真</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319213629802.png" alt="三极管型LDO仿真"></p><h3 id="MOS管型LDO原理推导："><a href="#MOS管型LDO原理推导：" class="headerlink" title="MOS管型LDO原理推导："></a>MOS管型LDO原理推导：</h3><p>​MOS管型LDO与三极管型LDO的差别在于它所使用的管子不同。在结构相同的条件下，可直接替换管子进行分析。</p><h4 id="MOS管的漏源电流工作区特性"><a href="#MOS管的漏源电流工作区特性" class="headerlink" title="MOS管的漏源电流工作区特性"></a>MOS管的漏源电流工作区特性</h4><p>​在拉扎维中，对MOS管的讨论在三极管区和饱和区。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319215652655.png" alt="MOS管的三极管区"></p><p>​<strong>此时电流公式为：</strong><br>$$<br>I_D&#x3D;\mu\cdot\frac{\epsilon_{ox}}{t_{ox}}\cdot\frac WL\cdot\left[(V_{GS}-V_{TH})\cdot V_{DS}-\frac12V_{DS}^2\right]<br>$$<br><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319215527746.png" alt="MOS管的饱和区"></p><p>​<strong>此时电流公式为：</strong><br>$$<br>I_D&#x3D;\frac12\beta\frac W{L^{\prime}}(V_{GS}-V_{TH})^2<br>$$<br>​由上图可以发现两个工作区的漏源电流公式只有VGS一个变量，那么从这里就可以看出MOS管的LDO原理依旧是依靠误差放大器所带来的<strong>电压变化</strong>引起功率输出级的<strong>电流变化</strong>。</p><h4 id="MOS管型LDO中MOS管的工作区"><a href="#MOS管型LDO中MOS管的工作区" class="headerlink" title="MOS管型LDO中MOS管的工作区"></a>MOS管型LDO中MOS管的工作区</h4><p>​从上文中的MOS管漏源电流公式以及电流输出图像，可以看出MOS管的漏源电流输出并不像三极管的电流输出机制。<br>​MOS管的工作区需要从VGS和VDS两个方面进行分析，MOS管型的LDO可能会工作在三极管区或者饱和区。但为了达到一个较为良好的工作环境（低压降）设计师常常将工作区设置在饱和区中，只有在特殊条件下LDO才会工作在三极管区。<br>​压降小时工作在线性区，损耗由导通电阻和电流决定；压降大时工作在饱和区，损耗由压降和电流决定，工作在饱和区时，环路性能比线性区好，但压降损耗增大。<br>​线性区由于其增益比饱和区小，所以环路相对较差。但在补偿的条件下现在的确已经可以控制，并正常使用。</p><h4 id="MOS管型LDO简单仿真"><a href="#MOS管型LDO简单仿真" class="headerlink" title="MOS管型LDO简单仿真"></a>MOS管型LDO简单仿真</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240319223126591.png" alt="MOS管型LDO仿真"></p><h2 id="三、LDO输出公式推导"><a href="#三、LDO输出公式推导" class="headerlink" title="三、LDO输出公式推导"></a>三、LDO输出公式推导</h2><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240320102813834.png" alt="环路控制"></p><p>​如图，将mos管到输出负载电阻部分的传递函数设为H(S),再将误差放大器的反馈环的传递函数设为G(s)，那么，此时系统整体传递函数流程图为：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240320102625921.png" alt="传递函数流程图"></p><p>​但在该系统中，当Vin为定值时，可以暂且不以Vin为系统输入。那么我们可以看到此时Q1处MOS管三个引脚，D为Vin(定值)，S为Vout（输出），那么我们只能从G级看起，将Vc作为新的输入。<br>​那么此时有新的传递函数，为：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240320103406712.png" alt="功率级传递函数"></p><p>​又已知：<br>$$<br>Vc(s)&#x3D;Verr(s)×G(s)<br>$$<br>​<br>$$<br>Verr(s)&#x3D;Vref(s)-\alpha Vout(s) 此处\alpha为电阻分压系数<br>$$<br>​那么加以转换，可得到新的系统传递函数为（此处Zout可看作MOS管漏源电阻）：</p><p>​<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240320103530327.png"></p><p>​那么，此时的闭环输出公式为：<br>$$<br>V_{\mathrm{out}}(s)&#x3D;\frac{V_{\mathrm{ref}}(s)}{\alpha}\frac{G(s)H(s)}{1+G(s)H(s)}-\frac{Z_{\mathrm{out},0\mathrm{l}}(s)}{1+G(s)H(s)}I_{\mathrm{out}}(s)<br>$$<br>​显然可得，当开环增益G(s)H(s)足够大时，有公式为：<br>$$<br>V_{\mathrm{out}}&#x3D;\frac{V_{\mathrm{ref}}}\alpha<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LDO工作原理简单探讨&quot;&gt;&lt;a href=&quot;#LDO工作原理简单探讨&quot; class=&quot;headerlink&quot; title=&quot;LDO工作原理简单探讨&quot;&gt;&lt;/a&gt;LDO工作原理简单探讨&lt;/h1&gt;&lt;h2 id=&quot;一、LDO介绍&quot;&gt;&lt;a href=&quot;#一、LDO介绍&quot; c</summary>
      
    
    
    
    <category term="硬件探讨" scheme="https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"/>
    
    
    <category term="小知识" scheme="https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集</title>
    <link href="https://lilongxin178.github.io/2024/01/10/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E6%9C%BAADC%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%BB%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%87%87%E9%9B%86/"/>
    <id>https://lilongxin178.github.io/2024/01/10/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E6%9C%BAADC%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%BB%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%87%87%E9%9B%86/</id>
    <published>2024-01-10T06:00:00.000Z</published>
    <updated>2024-02-25T12:55:24.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集"><a href="#TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集" class="headerlink" title="TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集"></a>TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集</h1><h2 id="一、搭建从机向主机发送ADC采集数据的代码模型"><a href="#一、搭建从机向主机发送ADC采集数据的代码模型" class="headerlink" title="一、搭建从机向主机发送ADC采集数据的代码模型"></a>一、搭建从机向主机发送ADC采集数据的代码模型</h2><h3 id="（1）代码模型功能"><a href="#（1）代码模型功能" class="headerlink" title="（1）代码模型功能"></a>（1）代码模型功能</h3><p>​该代码模型先由ADC进行电压采集，再进行数据的判断。在1.65V及以上，闪烁F280049评估版上的LED5，反之闪烁LED4。</p><h3 id="（2）添加所需模块，以及部分模块设置"><a href="#（2）添加所需模块，以及部分模块设置" class="headerlink" title="（2）添加所需模块，以及部分模块设置"></a>（2）添加所需模块，以及部分模块设置</h3><h4 id="1-添加一个ADC模块，其参数按默认设置"><a href="#1-添加一个ADC模块，其参数按默认设置" class="headerlink" title="1.添加一个ADC模块，其参数按默认设置"></a>1.添加一个ADC模块，其参数按默认设置</h4><h4 id="2-添加一个SCITransmit模块，其参数按默认设置"><a href="#2-添加一个SCITransmit模块，其参数按默认设置" class="headerlink" title="2.添加一个SCITransmit模块，其参数按默认设置"></a>2.添加一个SCITransmit模块，其参数按默认设置</h4><h4 id="3-添加两个CompareToConstant模块-按照下图的参数进行配置"><a href="#3-添加两个CompareToConstant模块-按照下图的参数进行配置" class="headerlink" title="3.添加两个CompareToConstant模块,按照下图的参数进行配置"></a>3.添加两个CompareToConstant模块,按照下图的参数进行配置</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225201345884.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225201353863.png"></p><h4 id="4-添加一个Rate-Transition模块"><a href="#4-添加一个Rate-Transition模块" class="headerlink" title="4.添加一个Rate Transition模块"></a>4.添加一个Rate Transition模块</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225202117277.png"></p><h4 id="5-添加两个-Digital-Output-模块（配置LED所在的GPIO进行翻转）"><a href="#5-添加两个-Digital-Output-模块（配置LED所在的GPIO进行翻转）" class="headerlink" title="5.添加两个 Digital Output 模块（配置LED所在的GPIO进行翻转）"></a>5.添加两个 Digital Output 模块（配置LED所在的GPIO进行翻转）</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225202238625.png"></p><h4 id="6-完成从机（F280049）板载程序的代码模型"><a href="#6-完成从机（F280049）板载程序的代码模型" class="headerlink" title="6.完成从机（F280049）板载程序的代码模型"></a>6.完成从机（F280049）板载程序的代码模型</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225202356536.png"></p><p>​最后进行下载即可。</p><h2 id="二、通过使用SCI模块在主机（Simulink）上显示ADC模块所采集到的数据"><a href="#二、通过使用SCI模块在主机（Simulink）上显示ADC模块所采集到的数据" class="headerlink" title="二、通过使用SCI模块在主机（Simulink）上显示ADC模块所采集到的数据"></a>二、通过使用SCI模块在主机（Simulink）上显示ADC模块所采集到的数据</h2><h3 id="（1）主机模型功能"><a href="#（1）主机模型功能" class="headerlink" title="（1）主机模型功能"></a>（1）主机模型功能</h3><p>​该代码模型由SCI Setup模块和SCI Receive模块进行数据的采集，并对采集回的数据进行处理对电压进行计算并输出在Scope模块上。</p><h3 id="（2）搭建主机模型"><a href="#（2）搭建主机模型" class="headerlink" title="（2）搭建主机模型"></a>（2）搭建主机模型</h3><h4 id="1-添加模块与参数设置"><a href="#1-添加模块与参数设置" class="headerlink" title="1.添加模块与参数设置"></a>1.添加模块与参数设置</h4><h5 id="1-添加一个-Host-SCI-Setup-模块（由于从机SCI未进行设置，此处可直接使用默认设置）。"><a href="#1-添加一个-Host-SCI-Setup-模块（由于从机SCI未进行设置，此处可直接使用默认设置）。" class="headerlink" title="(1)添加一个 Host&#x2F;SCI Setup 模块（由于从机SCI未进行设置，此处可直接使用默认设置）。"></a>(1)添加一个 Host&#x2F;SCI Setup 模块（由于从机SCI未进行设置，此处可直接使用默认设置）。</h5><p><strong>PS:如果用户的C2000 LaunchPad XL实验板的串口号不是1-4，请先行将串口号修改为1-4，然后才能进行下面的工作。</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225203046915.png"></p><h5 id="2-添加一个-Host-SCI-Receive-模块。"><a href="#2-添加一个-Host-SCI-Receive-模块。" class="headerlink" title="(2)添加一个 Host&#x2F;SCI Receive 模块。"></a>(2)添加一个 Host&#x2F;SCI Receive 模块。</h5><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225204758006.png"></p><h5 id="3-添加一个-Gain-模块（因为电压轨为3-3V，ADC为12位为4096，故参数设为3-3-4096）"><a href="#3-添加一个-Gain-模块（因为电压轨为3-3V，ADC为12位为4096，故参数设为3-3-4096）" class="headerlink" title="(3)添加一个 Gain 模块（因为电压轨为3.3V，ADC为12位为4096，故参数设为3.3&#x2F;4096）"></a>(3)添加一个 Gain 模块（因为电压轨为3.3V，ADC为12位为4096，故参数设为3.3&#x2F;4096）</h5><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225203817740.png"></p><h4 id="（4）主机模型"><a href="#（4）主机模型" class="headerlink" title="（4）主机模型"></a>（4）主机模型</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225203900878.png"></p><h4 id="（5）进行保存，点击运行"><a href="#（5）进行保存，点击运行" class="headerlink" title="（5）进行保存，点击运行"></a>（5）进行保存，点击运行</h4><p>​可以看到开发板在接入3.3V时，LED5闪烁。当ADC引脚接入GND时，LED4闪烁。</p><p>​使用上位机进行数据检测，当接入3.3V时</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225204828589.png"></p><p>​从结果看，SCI通信与ADC检测均无误。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="串口号修改"><a href="#串口号修改" class="headerlink" title="串口号修改"></a>串口号修改</h3><h4 id="1-打开设备管理器"><a href="#1-打开设备管理器" class="headerlink" title="1.打开设备管理器"></a>1.打开设备管理器</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225205058683.png"></p><h4 id="2-右击你需要修改串口号的设备，点击属性"><a href="#2-右击你需要修改串口号的设备，点击属性" class="headerlink" title="2.右击你需要修改串口号的设备，点击属性"></a>2.右击你需要修改串口号的设备，点击属性</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225205206033.png"></p><h4 id="3-在“端口设置”中选择“高级”"><a href="#3-在“端口设置”中选择“高级”" class="headerlink" title="3.在“端口设置”中选择“高级”"></a>3.在“端口设置”中选择“高级”</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225205234677.png"></p><h4 id="4-进行修改并确认"><a href="#4-进行修改并确认" class="headerlink" title="4.进行修改并确认"></a>4.进行修改并确认</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240225205303342.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集&quot;&gt;&lt;a href=&quot;#TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集&quot; class=&quot;headerlink&quot; title=&quot;TI——C2000芯</summary>
      
    
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ADC、DAC的理论信噪比计算</title>
    <link href="https://lilongxin178.github.io/2024/01/03/ADC%E3%80%81DAC%E7%9A%84%E7%90%86%E8%AE%BA%E4%BF%A1%E5%99%AA%E6%AF%94%E8%AE%A1%E7%AE%97/"/>
    <id>https://lilongxin178.github.io/2024/01/03/ADC%E3%80%81DAC%E7%9A%84%E7%90%86%E8%AE%BA%E4%BF%A1%E5%99%AA%E6%AF%94%E8%AE%A1%E7%AE%97/</id>
    <published>2024-01-03T06:00:00.000Z</published>
    <updated>2024-02-29T14:17:44.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ADC、DAC的理论信噪比计算"><a href="#ADC、DAC的理论信噪比计算" class="headerlink" title="ADC、DAC的理论信噪比计算"></a>ADC、DAC的理论信噪比计算</h1><h2 id="一、量化噪声模型以及转换器理论信噪比公式推导"><a href="#一、量化噪声模型以及转换器理论信噪比公式推导" class="headerlink" title="一、量化噪声模型以及转换器理论信噪比公式推导"></a>一、量化噪声模型以及转换器理论信噪比公式推导</h2><p>​理想转换器对信号进行数字化时，最大误差为±½ LSB，如图的一个理想N位ADC的传递函数所示。对于任何横跨数个LSB的交流信号，其量化误差可以通过一个峰峰值幅度为q (一个LSB的权重)的非相关锯齿波形来近似计算。对该近似法还可以从另一个角度来看 待，即实际量化误差发生在±1&#x2F;2* q范围内任意一点的概率相等。虽然这种分析不是百分之百 精确，但对大多数应用是足够准确的。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240229221606976.png" alt="理想N位ADC的量化噪声"></p><p>​有一种更详细地显示了量化误差与时间关系的图像。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240229213535383.png" alt="量化噪声与时间的关系"></p><p>​同样，一个简单的锯齿波形就能提供足够准 确的分析模型。锯齿误差的计算公式如下：<br>$$<br>\mathrm{e(t)&#x3D;st,-q&#x2F;2s&lt;t&lt;+q&#x2F;2s}<br>$$<br>​e(t)的均方值可以表示为：<br>$$<br>\overline{\mathrm{e}^2(t)}&#x3D;\frac{\mathrm{s}}{\mathrm{q}}{\int_{-\mathrm{q}&#x2F;2\mathrm{s}}^{+\mathrm{q}&#x2F;2\mathrm{s}}(\mathrm{s}t)}^2\mathrm{dt}<br>$$<br>​进行简单的积分和简化可得：<br>$$<br>\overline{\mathrm{e}^2(t)}&#x3D;\frac{\mathrm{q}^2}{12}.<br>$$<br>​因此，均方根量化误差为：<br>$$<br>均方根量化噪声&#x3D;\sqrt{\mathrm{e}^2(t)}&#x3D;\frac{\mathrm{q}}{\sqrt{12}}<br>$$<br>​锯齿误差波形产生的谐波远远超过DC至f s &#x2F;2的奈奎斯特带宽，然而，所有这些高阶谐波必 须折回(混叠)到奈奎斯特带宽并相加，产生q&#x2F;√12的均方根噪声。</p><p>​量化噪声近似于高斯分布，几乎均匀地分布于从DC至 f s &#x2F;2的奈奎斯特带宽。这里假设量化噪声与输入信号不相关。在某些条件下，当采样时钟和信号通过谐波相关时，量化噪声将与输入信号相关，能量集中在信号的谐波中，但均方 根值仍然约为q&#x2F;√12。理论信噪比现在可以通过一个满量程输入正弦波来计算：<br>$$<br>满量程输入正弦波&#x3D;\mathrm{v(t)&#x3D;\frac{q2^N}2\sin(2\pi ft)}<br>$$<br>​因此，输入信号的均方根值为：<br>$$<br>满量程输入的均方根值&#x3D;\frac{\mathrm{q}2^{\mathrm{N}}}{2\sqrt{2}}<br>$$<br>​因此，理想N位转换器的均方根信噪比为：<br>$$<br>\mathrm{SNR}&#x3D;20\log_{10}\frac{\text{rms value of FS input}}{\text{rms value of quantization noise}}<br>$$</p><p>$$<br>\mathrm{SNR&#x3D;20\log_{10}\left[\frac{q2^N&#x2F;2\sqrt{2}}{q&#x2F;\sqrt{12}}\right]&#x3D;20\log_{10}2^N+20\log_{10}\sqrt{\frac32}}<br>$$</p><p>$$<br>\mathrm{SNR}&#x3D;6.02\mathrm{N}+1.76\mathrm{dB}<br>$$</p><p>​虽然量化噪声的实际频谱相当复杂，难以分析，但推导出的简化分析对大多数应用足够准确。然而，必须再次强调，均方根量化噪声是在DC至fs&#x2F;2的完整 奈奎斯特带宽范围内进行测量。</p><h2 id="二、峰峰值分辨率与有效分辨率"><a href="#二、峰峰值分辨率与有效分辨率" class="headerlink" title="二、峰峰值分辨率与有效分辨率"></a>二、峰峰值分辨率与有效分辨率</h2><p>​低带宽、高分辨率ADC的分辨率为16位或24位。但是，器件的有效位数受噪声限制，而噪声则取决于输出字速率和所用的增益设置。有些公司规定使用有效分辨率来表示该参数。</p><p>​下图显示模拟输入接地时从一个Σ-Δ型ADC获得的典型直方图。理想情况下，对于这一固定的直流模拟输入，输出码应为0。但是，由于噪声影响，恒定模拟输入存在一个码字分布。此噪声包括ADC内部的热噪声和模数转换过程引起的量化噪声。 </p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240229215853416.png" alt="模拟输入接地时的直方图"></p><p>​码字分布一般为高斯分布。均方根噪声是通过从该直方图产生的曲线计算出的，曲线的宽度决定均方根噪声。高斯曲线的分布是从负无穷大到正无穷大。然而，99.99%的码 字出现在6.6倍均方根噪声范围内。因此，峰峰值噪声为均方根噪声的6.6倍。 </p><p>​数据手册一般使用均方根噪声。噪声取决于所用的滤波器 频率和增益设置。通常，当模拟输入范围缩小时，均方根噪声也会变小。但是，由于满量程模拟输入信号也被减 小，因此有效位数降低。</p><p>​假设当模拟输入范围为+2.56 V且，均方根噪声等于1.25μV。根据该数据计算信噪比：<br>$$<br>(20\mathrm{log}((6.6\times1.25\text{E-6})&#x2F;(2.56\times2))&#x3D;-115.85\mathrm dB<br>$$<br>​据此计算峰峰值分辨率：<br>$$<br>115.85&#x3D;6.02\mathrm{N}+1.76&#x3D;&gt;\mathrm{N}&#x3D;(115.85-1.76)&#x2F;6.02&#x3D;19\mathrm Bits<br>$$<br>​因此，在上述条件下，19个MSB中无闪烁位。 有些公司规定使用有效分辨率，而不是峰峰值分辨率。有效分辨率是通过均方根噪声而非峰值噪声计算出的。使用均方根噪声计算信噪比：<br>$$<br>(20\mathrm{log}((1.25\text{Е-}6)&#x2F;(2.56\times2))&#x3D;-132.25\mathrm dB<br>$$<br>​据此计算有效分辨率：<br>$$<br>\begin{aligned}132.25&amp;&#x3D;6.02\mathrm{N}+1.76&#x3D;&gt;\\\mathrm{N}&amp;&#x3D;(132.25-1.76)&#x2F;6.02&#x3D;21.7\mathrm Bits \end{aligned}<br>$$<br>​因此，有效分辨率 &#x3D; 峰峰值分辨率 + 2.7位。 评估ADC时，应当认识到有效分辨率与峰峰值分辨率的计算方法 不同，有效分辨率比峰峰值分辨率大2.7位。此外，有效分辨率没 有突出闪烁位数，峰峰值分辨率则指出了不闪烁的位数，因而能 更好地表示性能。</p><p>​对于一个ADC，其有效分辨率比峰峰值分辨 率高2.7位。因此，对于有效分辨率为22位的器件，其无闪烁分辨率为22 – 2.7 &#x3D; 19.3位。要了解器件对于一项应用的真正性能，必须确定所规定的是峰峰值分辨率还是有效分辨率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ADC、DAC的理论信噪比计算&quot;&gt;&lt;a href=&quot;#ADC、DAC的理论信噪比计算&quot; class=&quot;headerlink&quot; title=&quot;ADC、DAC的理论信噪比计算&quot;&gt;&lt;/a&gt;ADC、DAC的理论信噪比计算&lt;/h1&gt;&lt;h2 id=&quot;一、量化噪声模型以及转换器</summary>
      
    
    
    
    <category term="硬件探讨" scheme="https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"/>
    
    
    <category term="小知识" scheme="https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TI——C2000芯片自动代码生成及示例（一）</title>
    <link href="https://lilongxin178.github.io/2023/12/23/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://lilongxin178.github.io/2023/12/23/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-12-23T06:00:00.000Z</published>
    <updated>2024-02-18T07:54:26.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TI——C2000芯片自动代码生成及示例（一）"><a href="#TI——C2000芯片自动代码生成及示例（一）" class="headerlink" title="TI——C2000芯片自动代码生成及示例（一）"></a>TI——C2000芯片自动代码生成及示例（一）</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​本文在配置完代码生成环境的基础上，以TI——TMS320F280049芯片为例，介绍建立模型、生成C代码，最后将代码烧写到芯片当中的详细操作过程，以及在使用中的常见问题解决方案。</p><h2 id="二、操作流程及配置使用"><a href="#二、操作流程及配置使用" class="headerlink" title="二、操作流程及配置使用"></a>二、操作流程及配置使用</h2><h3 id="（1）新建工程及模型参数设置"><a href="#（1）新建工程及模型参数设置" class="headerlink" title="（1）新建工程及模型参数设置"></a>（1）新建工程及模型参数设置</h3><p>1.打开Simulink进行新建工程。</p><p>2.点击MODELING（建模）下的Model Settings（或快捷键Ctrl+E）打开模型参数配置页面：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218144417820.png"></p><p>3.由于芯片中运行的程序为离散信号，故将求解器中的步长类型设置为定步长，求解算法为离散模式，此处可设置步长时间为0.01s。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218144528205.png"></p><p>4.在Hardware Implementation（硬件实现）当中选择硬件型号。下拉可见在C2000系列各芯片型号，此处选择280049作为配置的芯片系列。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218144713966.png"></p><p>5.在Code Generation（代码生成）的Report（报告）处勾选Create Code generation report（创建代码生成报告）和 Open report automatically（自动生成报告），代码生成的过程中将自动生成报告。（其余选项非必选项，可依据需要进行勾选）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218145003013.png"></p><h3 id="（2）搭建F280049的GPIO点灯程序"><a href="#（2）搭建F280049的GPIO点灯程序" class="headerlink" title="（2）搭建F280049的GPIO点灯程序"></a>（2）搭建F280049的GPIO点灯程序</h3><p>​1.打开库浏览器</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218145233528.png"></p><p>2.搜索C2000，并寻找F280049型号芯片（或者你所使用的芯片型号）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218145412487.png"></p><p>3.双击打开该模块库，可以对其外设进行图形化设计。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218145603930.png"></p><p>4.在这里我们使用的是GPIO对LED进行控制，所以，可选择GPIO将其拖至Simulink的图纸上。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218145934181.png"></p><p>5.对GPIO配置完成后，给其一不断变换的常数，使其GPIO输出电平反转。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218150247290.png"></p><p>6.保存至工作文件夹</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218150323755.png"></p><h3 id="（3）代码生成（CCS下载和Simulink直接下载）"><a href="#（3）代码生成（CCS下载和Simulink直接下载）" class="headerlink" title="（3）代码生成（CCS下载和Simulink直接下载）"></a>（3）代码生成（CCS下载和Simulink直接下载）</h3><p>1.在模型搭建完成后，在HARDWARE界面点击Build（快捷键Ctrl+B），自动生成C代码</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218152937916.png"></p><p>2.在Diagnostic Viewer中出现Build process completed successfully证明代码已自动生成。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218153007404.png"></p><p>且此时，代码生成的报告也将出现。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218153035481.png"></p><p>3.此时，如果需要进行下载，可使用两种方式（MATLAB直接下载或者CCS进行下载）<br>    先对此处进行检查，确认该处下载器配置文件存在（若没有可以进入CCS重新配置保存，并导入此处）。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218153423368.png"></p><p>4.然后依旧在刚才的界面进行下载，使用这个按键<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218153607154.png" alt="image-20240218153607154">进行下载（Simulink直接下载)</p><p>4.打开CCS导入你所在的工作文件夹为CCS工程。（CCS下载）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218153815072.png"></p><p>导入工程后，使用CCXML文件进行下载。</p><h2 id="三、过程中遇到的问题及注意事项"><a href="#三、过程中遇到的问题及注意事项" class="headerlink" title="三、过程中遇到的问题及注意事项"></a>三、过程中遇到的问题及注意事项</h2><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>​1.MATLAB所有文件夹不要放置在存在中文的路径中。</p><p>​2.工作文件夹尽可能不要选择C盘，可能会存在某些文件由于权限不足无法打开的情况。</p><p>​3.Powershell的环境变量配置。（如果在编译时出现<strong>“代码生成文件不存在”</strong>的错误，且报错信息中存在<strong>“Powershell不是内部命令也不是外部命令”</strong>的话，极大可能为此处报错）</p><p>​4.也可能遇到CCS导入工程失败的问题。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>​1、2：改变工作文件夹的位置</p><p>​3.在环境变量path后添加powershell的路径（C:\Windows\System32\WindowsPowerShell\v1.0）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218155004593.png"></p><p>.4.CCS无法导入遇到下图情况：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240218155111409.png"></p><p>​（1）找到工程文件下面给的.cproject文件。<br>​（2）利用记事本或者能打开的工具打开，有一行文字格式为这样的注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tool id=<span class="string">&quot;xxxx&quot;</span> name=<span class="string">&quot;xxx&quot;</span> superClass=<span class="string">&quot;xxxxx&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>删除此行。<br>    （3)重新启动软件在此导入即可导入成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TI——C2000芯片自动代码生成及示例（一）&quot;&gt;&lt;a href=&quot;#TI——C2000芯片自动代码生成及示例（一）&quot; class=&quot;headerlink&quot; title=&quot;TI——C2000芯片自动代码生成及示例（一）&quot;&gt;&lt;/a&gt;TI——C2000芯片自动代码生成</summary>
      
    
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Stateflow 建模基础（1）</title>
    <link href="https://lilongxin178.github.io/2023/12/14/Stateflow%20%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <id>https://lilongxin178.github.io/2023/12/14/Stateflow%20%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</id>
    <published>2023-12-14T06:00:00.000Z</published>
    <updated>2024-02-13T04:20:32.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stateflow基础（1）"><a href="#Stateflow基础（1）" class="headerlink" title="Stateflow基础（1）"></a>Stateflow基础（1）</h1><h2 id="一、简介及Stateflow的特点"><a href="#一、简介及Stateflow的特点" class="headerlink" title="一、简介及Stateflow的特点"></a>一、简介及Stateflow的特点</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>​Stateflow是有限状态机(Finite State Machine，FSM)的图形实现工具，它可以用于解决事件驱动系统中复杂的逻辑问题。Stateflow 通过开发 FSM 和流程图的设计环境扩展Simulink的功能，在系统中可以用图形化的工具来实现各个状态之间的迁移。<br>​Stateflow 图表采用图形建模的方式构建层次化的、并行工作的状态和它们之间由事件驱动的逻辑迁移关系。Stateflow 在传统状态图的基础上扩展了控制流、MATLAB 函数、图形函数、真值表、临时运算符、直接事件广播，并可以集成用户自编 C 代码，而且通过Stateflow Coder 可以为 Stateflow 状态图模型自动生成C代码。</p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><p>Stateflow的主要特点如下:<br>    (1)提供层次化、可并行的、具有明确执行语义的建模语言元素，并以自然易懂的形式来描述复杂逻辑系统。<br>    (2)使用流程图定义图形化函数，使用 MATLAB 函数进行编程操作，使用真值表完成表格形式的处理。<br>    (3)采用临时逻辑调度状态迁移与事件<br>    (4)支持Mealy和Moore有限状态机。<br>    (5)可集成用户自定义输人输出变量的C代码<br>    (6)支持向量、矩阵、总线信号和定点数据类型。<br>    (7)可进行静态模型检查，包括病态定义的真值表。<br>    (8)可动态检测迁移冲突、死循环、状态不一致、数据范围错误和溢出问题(9)仿真进行中以动画显示状态图的运行并记录数据，以便于对系统的理解和调试。<br>    (10)集成了一个调试器，采用图形化断点进行单步调试，在调试时浏览其中的数据</p><h2 id="二、构造并运行Stateflow图（设计过零比较器）"><a href="#二、构造并运行Stateflow图（设计过零比较器）" class="headerlink" title="二、构造并运行Stateflow图（设计过零比较器）"></a>二、构造并运行Stateflow图（设计过零比较器）</h2><h3 id="1-打开-Stateflow-编辑器"><a href="#1-打开-Stateflow-编辑器" class="headerlink" title="1.打开 Stateflow 编辑器"></a>1.打开 Stateflow 编辑器</h3><p>​Stateflow 编辑器是一个图形环境，用于设计状态转移图、流程图、状态转移表和真值表。</p><ul><li><p>要建立周期性或连续时间 Simulink 算法的条件、基于事件和基于时间的逻辑模型，请使用 [<strong>sfnew</strong>] 函数创建一个可在 Simulink 模型中作为模块进行仿真的 Stateflow 图。在 MATLAB 命令提示符处，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfnew rectify     % 在simulink中创建一个仿真图表</span><br></pre></td></tr></table></figure><p>Simulink 创建一个名为 <code>rectify</code> 的模型，其中包含一个空的 Stateflow Chart 模块。要打开 Stateflow 编辑器，请双击图模块。</p></li><li><p>要为 MATLAB 应用程序设计可重用的状态机和时序逻辑，请使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/edit.html"><code>edit</code></a> 函数创建可作为 MATLAB 对象执行的独立 Stateflow 图。在 MATLAB 命令提示符处，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit rectify.sfx  % 创建图表执行作为Matlab对象</span><br></pre></td></tr></table></figure><p>如果文件 <code>rectify.sfx</code> 不存在，Stateflow 编辑器将创建名为 <code>rectify</code> 的空图。</p></li></ul><p>​Stateflow 编辑器的主要组件是图画布、对象选项板和<strong>符号</strong>窗格。</p><ul><li>图画布是一个绘图区域，可以在其中通过组合状态、转移和其他图形元素来创建图。</li><li>在画布的左侧有一个对象选项板，其中显示了一组可向图中添加图形元素的工具。</li><li>在画布的右侧有一个<strong>符号</strong>窗格，您可以用它向图添加新的数据、事件和消息并解析任何未定义或未使用的符号。</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240211150325306.png"></p><p>PS:在构造 Stateflow 图后，您可以将其内容复制到另一个具有不同执行模式的图中。例如，您可以构造在 MATLAB 中执行的图，并将其内容复制到在 Simulink 中进行仿真的图中。</p><h3 id="2-添加状态和转移"><a href="#2-添加状态和转移" class="headerlink" title="2.添加状态和转移"></a>2.添加状态和转移</h3><ol><li><p>在对象选项板中，点击状态图标并将指针移至图画布。将出现具有默认转移的状态。要放置该状态，请点击画布上的某个位置。在文本提示中，输入状态名称 <code>On</code> 和状态动作 <code>y = x</code>。</p><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20240213114415574.png"></p></li><li><p>添加另一个状态。右键点击并拖动 <code>On</code> 状态。蓝色图形提示可以帮助您水平或垂直对齐状态。新状态的名称变为 <code>Off</code>。双击该状态并将状态动作修改为 <code>y = 0</code>。</p></li><li><p>重新对齐两个状态并在两个状态之间的空白处停留片刻出现蓝色转移提示指示进行连接。</p></li><li><p>双击每个转移并输入适当的转移条件 <code>x&lt;t0</code> 或 <code>x&gt;=t0</code>。条件出现在方括号内。（选择添加转移表达式）</p><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20240213114517613.png"></p><p>5.结果如下图：</p><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20240213114549731.png"></p></li></ol><h3 id="3-解析未定义的符号"><a href="#3-解析未定义的符号" class="headerlink" title="3.解析未定义的符号"></a>3.解析未定义的符号</h3><p>​在执行图之前，必须定义图中使用的每个符号并指定其作用域（例如，输入数据、输出数据或局部数据）。</p><p>​（1）打开<strong>符号</strong>窗格。<br>​（2）在<strong>符号</strong>窗格中，点击<strong>解析未定义的符号</strong></p><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20240213114810053.png"></p><p>​（3）由于阈值 <code>t0</code> 在仿真过程中不会更改，因此将其作用域更改为常量数据。在<strong>类型</strong>列中，点击 <code>t0</code> 旁边的数据类型图标，然后选择<strong>常量数据</strong>。<br>​（4）设置阈值 <code>t0</code> 的值。在<strong>值</strong>列中，点击 <code>t0</code> 旁边的空白输入框，并输入值 0。<br>​（5）保存Stateflow 图。</p><h3 id="4-进行仿真"><a href="#4-进行仿真" class="headerlink" title="4.进行仿真"></a>4.进行仿真</h3><p>​（1）要返回到 Simulink 编辑器，请在画布顶部的浏览器栏中点击 Simulink 模型的名称：<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/simulink-model.png"><strong>rectify</strong>。如果浏览器栏不可见，请点击对象选项板顶部的<strong>隐藏&#x2F;显示资源管理器栏</strong>图标 <img src="https://ww2.mathworks.cn/help/stateflow/gs/palette-explorer-bar.png">。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240213115108954.png"></p><p>​（2）执行以下操作以将信源添加到模型中：</p><ul><li>从 Simulink Sources 库中，添加一个 Sine Wave (Simulink) 模块。</li><li>双击 Sine Wave 模块并将<strong>采样时间</strong>设置为 0.2。</li><li>将 Sine Wave 模块的输出连接到 Stateflow 图的输入。</li><li>将信号标记为 <code>x</code>。</li></ul><p>​（3）添加一个示波器。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240213115412488.png"></p><p>​（4）保存 Simulink 模型。</p><p>​（5）开始仿真。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240213115521711.png"></p><p>​可以看到此处小于0的数据被滤除了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Stateflow基础（1）&quot;&gt;&lt;a href=&quot;#Stateflow基础（1）&quot; class=&quot;headerlink&quot; title=&quot;Stateflow基础（1）&quot;&gt;&lt;/a&gt;Stateflow基础（1）&lt;/h1&gt;&lt;h2 id=&quot;一、简介及Stateflow的特点</summary>
      
    
    
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Simulink建模基础（2）</title>
    <link href="https://lilongxin178.github.io/2023/12/12/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
    <id>https://lilongxin178.github.io/2023/12/12/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</id>
    <published>2023-12-12T06:00:00.000Z</published>
    <updated>2024-02-08T05:55:51.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Simulink建模基础（2）"><a href="#Simulink建模基础（2）" class="headerlink" title="Simulink建模基础（2）"></a>Simulink建模基础（2）</h1><h2 id="三、数学表达式模型搭建技巧"><a href="#三、数学表达式模型搭建技巧" class="headerlink" title="三、数学表达式模型搭建技巧"></a>三、数学表达式模型搭建技巧</h2><p>​本节对公式：<br>$$<br>y(t)&#x3D;A*e^{-t\over a}+{K\over\alpha}e^{-t\over a}\int_0^tx(\tau)e^{t\over a}d\tau+{\beta\over\alpha}e^{-t\over a}\int_0^tx(\tau^2)e^{t\over a}d\tau<br>$$<br>的数学表达式进行建模。</p><h3 id="1-先将结构进行剖析分解"><a href="#1-先将结构进行剖析分解" class="headerlink" title="1.先将结构进行剖析分解"></a>1.先将结构进行剖析分解</h3><h4 id="（1）将系统划分为几个子系统"><a href="#（1）将系统划分为几个子系统" class="headerlink" title="（1）将系统划分为几个子系统"></a>（1）将系统划分为几个子系统</h4><p>$$<br>y(t)&#x3D;Function1+Function2+Function3<br>$$</p><p>​所以，有<br>$$<br>Function1&#x3D;A*e^{-t\over a}<br>$$</p><p>$$<br>Function2&#x3D;{K\over\alpha}e^{-t\over a}\int_0^tx(\tau)e^{t\over a}d\tau<br>$$</p><p>$$<br>Function3&#x3D;{\beta\over\alpha}e^{-t\over a}\int_0^tx(\tau^2)e^{t\over a}d\tau<br>$$</p><h4 id="（2）此时再将子系统划分为各个小块。如："><a href="#（2）此时再将子系统划分为各个小块。如：" class="headerlink" title="（2）此时再将子系统划分为各个小块。如："></a>（2）此时再将子系统划分为各个小块。如：</h4><p>$$<br>Function1&#x3D;block1+block2<br>$$</p><p>$$<br>Function2 &#x3D; block2 * block3 * block4<br>$$</p><p>$$<br>Function3&#x3D; block2 *block5 *block6<br>$$</p><p>​所以可得出<br>$$<br>block1&#x3D;A<br>$$</p><p>$$<br>block2&#x3D;e^{-t\over a}<br>$$</p><p>$$<br>block3&#x3D;{K\over\alpha}<br>$$</p><p>$$<br>block4&#x3D;\int_0^tx(\tau)e^{t\over a}d\tau<br>$$</p><p>$$<br>block5&#x3D;{\beta\over\alpha}<br>$$</p><p>$$<br>block6&#x3D;e^{-t\over a}\int_0^tx(\tau^2)e^{t\over a}d\tau<br>$$</p><h3 id="2-开始进行建模"><a href="#2-开始进行建模" class="headerlink" title="2.开始进行建模"></a>2.开始进行建模</h3><h4 id="（1）创建上文所使用的六个模块"><a href="#（1）创建上文所使用的六个模块" class="headerlink" title="（1）创建上文所使用的六个模块"></a>（1）创建上文所使用的六个模块</h4><p>​如图，先创建Function1：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208120031353.png"></p><p>​再创建Function2，以及Function3</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208121909088.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208122525137.png"></p><h4 id="（2）建立子系统"><a href="#（2）建立子系统" class="headerlink" title="（2）建立子系统"></a>（2）建立子系统</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208123003149.png"></p><p>​将三个子系统建立完成后：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208123129427.png"></p><p>​（3）进行三个子系统的连接</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208123604094.png"></p><h3 id="3-模型仿真及测试"><a href="#3-模型仿真及测试" class="headerlink" title="3.模型仿真及测试"></a>3.模型仿真及测试</h3><h4 id="（1）添加测试用例及显示设备"><a href="#（1）添加测试用例及显示设备" class="headerlink" title="（1）添加测试用例及显示设备"></a>（1）添加测试用例及显示设备</h4><p>​添加一个正弦信号模块作为测试用例并按默认设置。</p><p>​添加一个示波器模块作为显示设备。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208125608784.png"></p><p>​双击该模块，在打开后界面的左上角，点击“视图”-&gt;”配置属性”，打开下图界面。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208125805465.png"></p><p>​设置完成后，为下图样式：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208125855458.png"></p><h4 id="（2）对参数进行设置"><a href="#（2）对参数进行设置" class="headerlink" title="（2）对参数进行设置"></a>（2）对参数进行设置</h4><p>​1.按照上文参数设置，对该建模内未定义的参数进行定义并赋值。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208130036883.png"></p><p>​2.设置仿真停止时间</p><p>​3.设置求解器类型（变步长）；并选择ode23的求解器。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208130153287.png"></p><p>​4.进行仿真</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208130647616.png" alt="、"></p><h2 id="四、Simulink仿真的各种波形显示方式"><a href="#四、Simulink仿真的各种波形显示方式" class="headerlink" title="四、Simulink仿真的各种波形显示方式"></a>四、Simulink仿真的各种波形显示方式</h2><h3 id="1-普通示波器Scope"><a href="#1-普通示波器Scope" class="headerlink" title="1.普通示波器Scope"></a>1.普通示波器Scope</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208132733862.png"></p><p>​调用方式：库浏览器中搜索Scope，拖出使用即可。</p><h3 id="2-Dashboard-Scope示波器"><a href="#2-Dashboard-Scope示波器" class="headerlink" title="2.Dashboard Scope示波器"></a>2.Dashboard Scope示波器</h3><p>（1）添加Dashboard Scope模块,即在模型的空白处单击选中该模型然后键人“dash”接着选中Dashboard Scope</p><p>（2）连接Dashboard Scope模块即双击 Dashboard Scope模块，打开模块参数对话框接着选中需要显示的信号，这些信号将出现在模块参数对话框中。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208133427148.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208133443871.png"></p><h3 id="3-仿真数据检查器（Data-Inspector）"><a href="#3-仿真数据检查器（Data-Inspector）" class="headerlink" title="3.仿真数据检查器（Data Inspector）"></a>3.仿真数据检查器（Data Inspector）</h3><p>​为了在一个页面中显示多个信号的波形，或对某个&#x2F;多个信号的多次测试进行记录，以优化模型中的参数等可使用 Data Inspector。如同时观察x(t)、y(t)、Functionl、Function2和Function3等信号。</p><p>​（1）右击需要的信号选择“记录所选信号”</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208133804426.png"></p><p>​（2）将所需信号全部按上述操作进行处理</p><p>​（3）找到已经选择的信号，再次右击打开仿真数据检查器。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208134009254.png"></p><p>​（4）对信号在此进行简单的归位排序，以便查看。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208134100578.png" alt="image-20240208134100578"></p><p>​（5）记录多次仿真结果。利用该记录功能可对比在不同参数条件下的输出波形，从而选择模型中更符合实际的参数。</p><h3 id="4-逻辑分析仪-Logic-Analyzer-。"><a href="#4-逻辑分析仪-Logic-Analyzer-。" class="headerlink" title="4.逻辑分析仪(Logic Analyzer)。"></a>4.逻辑分析仪(Logic Analyzer)。</h3><p>​对于选中的信号可以一次性将其波形显示出来，特别适用于逻辑关系比较明显的系统其操作方法为:选择 Logic Analyzer 选项即可打开逻辑分析仪对话框。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208134924139.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240208134958742.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Simulink建模基础（2）&quot;&gt;&lt;a href=&quot;#Simulink建模基础（2）&quot; class=&quot;headerlink&quot; title=&quot;Simulink建模基础（2）&quot;&gt;&lt;/a&gt;Simulink建模基础（2）&lt;/h1&gt;&lt;h2 id=&quot;三、数学表达式模型搭建技巧</summary>
      
    
    
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Simulink建模基础（1）</title>
    <link href="https://lilongxin178.github.io/2023/12/11/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <id>https://lilongxin178.github.io/2023/12/11/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</id>
    <published>2023-12-11T06:00:00.000Z</published>
    <updated>2024-02-06T06:17:34.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Simulink建模基础（1）"><a href="#Simulink建模基础（1）" class="headerlink" title="Simulink建模基础（1）"></a>Simulink建模基础（1）</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​Simulink是动态和嵌人式等系统的建模与仿真工具，也是模型设计的基础。对于机电航空航天、信号处理、自动控制、通信、音视频处理等众多领域，Simulink 提供了交互式可视化开发环境和可定制的模块库，对系统进行建模、仿真与调试等;并可实现与 Stateflow有限状态机的无缝连接，扩展对复杂系统的建模能力。<br>​通过Simulink模块库自带的1000多个预定义模块基本上可快速地创建基于MCU器件应用的系统模型。运用层次化建模、数据管理、子系统定制等手段，即使是复杂的嵌入式MCU应用系统，也能轻松地完成简明精确的模型描述。</p><p>​<strong>主要内容：</strong></p><ul><li>​Simulink基本操作</li><li>Simulink模块库简介</li><li>Simulink建模新方法介绍</li><li>物理建模简介</li></ul><h2 id="二、Simulink基本操作"><a href="#二、Simulink基本操作" class="headerlink" title="二、Simulink基本操作"></a>二、Simulink基本操作</h2><h3 id="2-1模块库和编辑窗口"><a href="#2-1模块库和编辑窗口" class="headerlink" title="2.1模块库和编辑窗口"></a>2.1模块库和编辑窗口</h3><h4 id="2-1-1-打开Simulink的起始页"><a href="#2-1-1-打开Simulink的起始页" class="headerlink" title="2.1.1  打开Simulink的起始页"></a>2.1.1  打开Simulink的起始页</h4><p>​在MATLAB的命令行窗口中输人Simulink指令或单击MATLAB工具栏上的Simulink图标，可打开Simulink的起始页。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240205140320152.png"></p><h4 id="2-1-2-打开模型编辑窗口"><a href="#2-1-2-打开模型编辑窗口" class="headerlink" title="2.1.2  打开模型编辑窗口"></a>2.1.2  打开模型编辑窗口</h4><p>​创建一个新的模型，首先要打开一个模型编辑窗口。可以通过单击“Simulink的起始页”上所需要的模板，这里选择空白模型(Blank Model)来打开编辑窗口。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240205140640287.png"></p><h4 id="2-1-3-打开Simulink库浏览器查看Simulink模块库中包含的子库"><a href="#2-1-3-打开Simulink库浏览器查看Simulink模块库中包含的子库" class="headerlink" title="2.1.3  打开Simulink库浏览器查看Simulink模块库中包含的子库"></a>2.1.3  打开Simulink库浏览器查看Simulink模块库中包含的子库</h4><p>​单击图3.2工具栏上的“库浏览器”图标，可查看Simulink 模块库所包含的子库。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240205141038552.png"></p><h3 id="2-2-建模示例"><a href="#2-2-建模示例" class="headerlink" title="2.2 建模示例"></a>2.2 建模示例</h3><h4 id="2-2-1-有物理含义或微分方程创建模型"><a href="#2-2-1-有物理含义或微分方程创建模型" class="headerlink" title="2.2.1  有物理含义或微分方程创建模型"></a>2.2.1  有物理含义或微分方程创建模型</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206132011400.png"></p><h5 id="1-求解负载电阻R上消耗功率的数学表达式"><a href="#1-求解负载电阻R上消耗功率的数学表达式" class="headerlink" title="1.求解负载电阻R上消耗功率的数学表达式"></a>1.求解负载电阻R上消耗功率的数学表达式</h5><p>​根据欧姆定律，该电路的电流i可表示为：<br>$$<br>i&#x3D;{V_S\over R_s+R_L}<br>$$<br>​则负载电阻R上消耗的功率为<br>$$<br>P&#x3D;i^2*R_L<br>$$</p><h5 id="2-搭建Simulink-模型"><a href="#2-搭建Simulink-模型" class="headerlink" title="2.搭建Simulink 模型"></a>2.搭建Simulink 模型</h5><h6 id="1-模型所需模块分析"><a href="#1-模型所需模块分析" class="headerlink" title="(1)模型所需模块分析"></a>(1)模型所需模块分析</h6><p>​该模型可由3个 Constant 常数模块、1个Add 加法模块、1个 Divide 除法模块1个Product乘法模块1个Math Function 数学函数模块和1个Display 显示模块来表达。</p><h6 id="2-创建一个Simulink模型。"><a href="#2-创建一个Simulink模型。" class="headerlink" title="(2)创建一个Simulink模型。"></a>(2)创建一个Simulink模型。</h6><p>​D单击工具栏上的图标打开Simulink起始页新建一个空白的Simulink模型并另存为自己的工作文件夹中。<br>​从Simulink 模块库(Commonly Used Blocks、Math Operations 和 Sinks)中添加Constant模块、Add模块、Divide模块、Math Function模块、Product 模块和 Display模块等。</p><h6 id="3-搭建好的模型"><a href="#3-搭建好的模型" class="headerlink" title="(3)搭建好的模型"></a>(3)搭建好的模型</h6><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206134135298.png"></p><h3 id="2-3参数设置"><a href="#2-3参数设置" class="headerlink" title="2.3参数设置"></a>2.3参数设置</h3><h4 id="1-在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器："><a href="#1-在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器：" class="headerlink" title="1.在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器："></a>1.在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器：</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206134644517.png"></p><h4 id="2-选择Parameters-选中你要定义的变量位置，点击┇按钮"><a href="#2-选择Parameters-选中你要定义的变量位置，点击┇按钮" class="headerlink" title="2.选择Parameters,选中你要定义的变量位置，点击┇按钮"></a>2.选择Parameters,选中你要定义的变量位置，点击┇按钮</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206134818400.png"></p><h4 id="3-按照下图进行数据的创建："><a href="#3-按照下图进行数据的创建：" class="headerlink" title="3.按照下图进行数据的创建："></a>3.按照下图进行数据的创建：</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206134955118.png"></p><h4 id="4-在该界面进行参数的设置"><a href="#4-在该界面进行参数的设置" class="headerlink" title="4.在该界面进行参数的设置"></a>4.在该界面进行参数的设置</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206135126261.png"></p><h4 id="5-回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存"><a href="#5-回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存" class="headerlink" title="5.回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存"></a>5.回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存</h4><h4 id="6-进入保存好的Matlab文件，得到如图所示的配置文件。"><a href="#6-进入保存好的Matlab文件，得到如图所示的配置文件。" class="headerlink" title="6.进入保存好的Matlab文件，得到如图所示的配置文件。"></a>6.进入保存好的Matlab文件，得到如图所示的配置文件。</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206135433216.png"></p><p>​在这里可以对每个参数的值，类型等进行修改。</p><h4 id="7-在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量-Value，如图所示。"><a href="#7-在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量-Value，如图所示。" class="headerlink" title="7.在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量.Value，如图所示。"></a>7.在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量.Value，如图所示。</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206135946132.png"></p><h4 id="8-点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了"><a href="#8-点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了" class="headerlink" title="8.点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了"></a>8.点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206140109850.png"></p><h4 id="9-选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入-m文件名-这样每次直接运行simlink文件时，会自动加载一次-m文件"><a href="#9-选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入-m文件名-这样每次直接运行simlink文件时，会自动加载一次-m文件" class="headerlink" title="9.选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入.m文件名,这样每次直接运行simlink文件时，会自动加载一次.m文件"></a>9.选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入.m文件名,这样每次直接运行simlink文件时，会自动加载一次.m文件</h4><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206140230252.png"></p><h3 id="2-4-模型仿真"><a href="#2-4-模型仿真" class="headerlink" title="2.4 模型仿真"></a>2.4 模型仿真</h3><p>​先对模型中各参数进行赋值，赋值后在simulink中，点击工具栏中的开始图标进行仿真。结果如下：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240206141323480.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Simulink建模基础（1）&quot;&gt;&lt;a href=&quot;#Simulink建模基础（1）&quot; class=&quot;headerlink&quot; title=&quot;Simulink建模基础（1）&quot;&gt;&lt;/a&gt;Simulink建模基础（1）&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="MATLAB学习" scheme="https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Matlab2022a离线安装Embedded Coder Support Package TI C2000</title>
    <link href="https://lilongxin178.github.io/2023/12/10/Matlab2022a%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Embedded%20Coder%20Support%20Package%20TI%20C2000/"/>
    <id>https://lilongxin178.github.io/2023/12/10/Matlab2022a%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Embedded%20Coder%20Support%20Package%20TI%20C2000/</id>
    <published>2023-12-10T06:00:00.000Z</published>
    <updated>2024-01-31T06:31:54.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab2022a离线安装Embedded-Coder-Support-Package-TI-C2000"><a href="#Matlab2022a离线安装Embedded-Coder-Support-Package-TI-C2000" class="headerlink" title="Matlab2022a离线安装Embedded Coder Support Package TI C2000"></a>Matlab2022a离线安装Embedded Coder Support Package TI C2000</h1><h2 id="一、了解Embedded-Coder-Support-Package-TI-C2000"><a href="#一、了解Embedded-Coder-Support-Package-TI-C2000" class="headerlink" title="一、了解Embedded Coder Support Package TI C2000"></a>一、了解Embedded Coder Support Package TI C2000</h2><p>​德州仪器 （TI） C2000 处理器的嵌入式编码器®支持包使您能够在 TI C2000™ MCU 上运行 Simulink® 模型。Embedded Coder 会自动为您的算法和设备驱动程序模块生成 C 代码，这些代码可直接在目标硬件上运行。该支持包可用于不同控制应用（包括电机控制和电源转换）的快速原型制作和生产工作流程。</p><p>​<strong>内容</strong></p><ul><li>从 Simulink 模型生成代码并部署到 TI C2000 硬件</li><li>用于 ADC、PWM、SPI、I2C、串行、SDFM、CAN、硬件中断、eCAP、QEP、比较器、DAC 等的设备驱动程序模块。</li><li>支持多核处理器</li><li>支持控制律加速器 （CLA）</li><li>具有处理器在环 （PIL）、监控和调谐（外部模式）、SD 卡记录和实时分析的验证功能</li><li>IQMath 的代码替换库</li><li>电机控制和功率转换应用实例</li></ul><p>​我们可以看到该工具性能十分强大，下面我们来对其进行离线安装。</p><h2 id="二、离线安装Embedded-Coder-Support-Package-TI-C2000"><a href="#二、离线安装Embedded-Coder-Support-Package-TI-C2000" class="headerlink" title="二、离线安装Embedded Coder Support Package TI C2000"></a>二、离线安装Embedded Coder Support Package TI C2000</h2><h3 id="1、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。"><a href="#1、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。" class="headerlink" title="1、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。"></a>1、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。</h3><h3 id="2、安装TI开发套件及SDK"><a href="#2、安装TI开发套件及SDK" class="headerlink" title="2、安装TI开发套件及SDK"></a>2、安装TI开发套件及SDK</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131103837453.png"></p><h3 id="3-下载supportsoftwaredownloader-r2022b-win64-exe"><a href="#3-下载supportsoftwaredownloader-r2022b-win64-exe" class="headerlink" title="3.下载supportsoftwaredownloader_r2022b_win64.exe"></a>3.下载<a href="https://ww2.mathworks.cn/supportfiles/downloads/R2022b/ssi_downloader/win64/SupportSoftwareDownloader_R2022b_win64.exe">supportsoftwaredownloader_r2022b_win64.exe</a></h3><h3 id="4-安装并进入登录界面登录（没有的话直接去Matlab官网申请）"><a href="#4-安装并进入登录界面登录（没有的话直接去Matlab官网申请）" class="headerlink" title="4.安装并进入登录界面登录（没有的话直接去Matlab官网申请）"></a>4.安装并进入登录界面登录（没有的话直接去Matlab官网申请）</h3><h3 id="5-选择自己安装的Matlab版本"><a href="#5-选择自己安装的Matlab版本" class="headerlink" title="5.选择自己安装的Matlab版本"></a>5.选择自己安装的Matlab版本</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131104306723.png"></p><h3 id="6-选择自己需要安装的支持包"><a href="#6-选择自己需要安装的支持包" class="headerlink" title="6.选择自己需要安装的支持包"></a>6.选择自己需要安装的支持包</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131104655371.png"></p><h3 id="7-选择默认安装路径"><a href="#7-选择默认安装路径" class="headerlink" title="7.选择默认安装路径"></a>7.选择默认安装路径</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131104727988.png"></p><h3 id="8-下载完成后会自动打开以下文件夹"><a href="#8-下载完成后会自动打开以下文件夹" class="headerlink" title="8.下载完成后会自动打开以下文件夹"></a>8.下载完成后会自动打开以下文件夹</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131104859096.png"></p><h3 id="9-打开readme，并复制当前文件夹路径"><a href="#9-打开readme，并复制当前文件夹路径" class="headerlink" title="9.打开readme，并复制当前文件夹路径"></a>9.打开readme，并复制当前文件夹路径</h3><p>​readme此处为Windows系统安装方式。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131105001248.png"></p><h3 id="10-按照readme的方式进行安装"><a href="#10-按照readme的方式进行安装" class="headerlink" title="10.按照readme的方式进行安装"></a>10.按照readme的方式进行安装</h3><p>​win+r打开cmd命令行</p><p>​先进入自己matlab默认安装文件夹–&gt;例如D:\MATLAB\R2022a\bin\win64</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131105313360.png"></p><p>​再使用readme中的名令打开supportsoftware.exe，进入安装。</p><h3 id="11-跟着系统提示安装即可。"><a href="#11-跟着系统提示安装即可。" class="headerlink" title="11.跟着系统提示安装即可。"></a>11.跟着系统提示安装即可。</h3><h3 id="12-安装完成后，找到MATLAB附加功能管理器，"><a href="#12-安装完成后，找到MATLAB附加功能管理器，" class="headerlink" title="12.安装完成后，找到MATLAB附加功能管理器，"></a>12.安装完成后，找到MATLAB附加功能管理器，</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131105817667.png"></p><p>13.选择自己需要的支持包</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131105844752.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131105936834.png"></p><p>逐步安装即可</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131110313408.png"></p><h3 id="13-打开一个示例并生成代码"><a href="#13-打开一个示例并生成代码" class="headerlink" title="13.打开一个示例并生成代码"></a>13.打开一个示例并生成代码</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131142824990.png"></p><h3 id="14-打开CCS进行编译"><a href="#14-打开CCS进行编译" class="headerlink" title="14.打开CCS进行编译"></a>14.打开CCS进行编译</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240131142926617.png"></p><p>​编译成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Matlab2022a离线安装Embedded-Coder-Support-Package-TI-C2000&quot;&gt;&lt;a href=&quot;#Matlab2022a离线安装Embedded-Coder-Support-Package-TI-C2000&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程</title>
    <link href="https://lilongxin178.github.io/2023/12/02/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%89%20%20TMS280049C%E8%AF%84%E4%BC%B0%E6%9D%BF%E4%B8%8B%E8%BD%BD%E8%AE%BE%E7%BD%AE%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
    <id>https://lilongxin178.github.io/2023/12/02/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%89%20%20TMS280049C%E8%AF%84%E4%BC%B0%E6%9D%BF%E4%B8%8B%E8%BD%BD%E8%AE%BE%E7%BD%AE%E5%8F%8A%E6%B5%81%E7%A8%8B/</id>
    <published>2023-12-02T06:00:00.000Z</published>
    <updated>2024-01-13T13:00:44.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TMS320F280049C主控的DSP入门设计（学习笔记二）-TMS280049C评估板下载设置及流程"><a href="#TMS320F280049C主控的DSP入门设计（学习笔记二）-TMS280049C评估板下载设置及流程" class="headerlink" title="TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程"></a>TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程</h1><h2 id="一、仿真器配置"><a href="#一、仿真器配置" class="headerlink" title="一、仿真器配置"></a>一、仿真器配置</h2><p>​对于280049C，其官方的LaunchPad开发板使用了XDS110仿真器的两线调试模式，而官方的ControlCard使用的是XDS100V2仿真器，开发时需要注意区分，并分别设置。本文以采用两线制调试的XDS110仿真器为例进行设置。<br>​右键点击工程名，选择New—&gt;TargetConfiguration File，File name取名任意，这里可取名为LaunchPad.ccxml，点击Finish。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113192342226.png"></p><p>​点击第三步的操作，进入如下图界面，选择JTAG_2_PIN调试模式。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113192419400.png"></p><h2 id="二、配置FLASH执行"><a href="#二、配置FLASH执行" class="headerlink" title="二、配置FLASH执行"></a>二、配置FLASH执行</h2><p>​当代码调试完毕后，需将代码烧录到FLASH中进行固化，使其掉电程序依旧储存在FLASH中。使DSP可以脱离仿真器运行。</p><h3 id="1-修改至FLASH模式"><a href="#1-修改至FLASH模式" class="headerlink" title="1.修改至FLASH模式"></a>1.修改至FLASH模式</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113193121668.png"></p><p>然后<strong>重复与RAM中执行类似的配置</strong>，具体包括以下几步：</p><ul><li>添加索引路径</li><li>添加数学库文件路径</li><li>启用FPU和TMU</li><li>定义_LAUNCHXL_F280049C</li><li>文件管理</li></ul><h3 id="2-声明-FLASH和code-start"><a href="#2-声明-FLASH和code-start" class="headerlink" title="2.声明_FLASH和code_start"></a>2.声明_FLASH和code_start</h3><p>为了使程序正确的从flash启动，编程时通常有一些特殊的代码需要运行(通常TI都已经在库函数中提供)。为了确保这些代码能够正确编译，执行本步骤。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113193234093.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113193306714.png"></p><h3 id="3-添加cmd文件"><a href="#3-添加cmd文件" class="headerlink" title="3.添加cmd文件"></a>3.添加cmd文件</h3><p>​将FLASH相关的cmd加进来。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113194459856.png"></p><h2 id="三、程序烧写与仿真"><a href="#三、程序烧写与仿真" class="headerlink" title="三、程序烧写与仿真"></a>三、程序烧写与仿真</h2><h3 id="1-连接仿真器（对于TMS280049C直接使用电脑供电即可）"><a href="#1-连接仿真器（对于TMS280049C直接使用电脑供电即可）" class="headerlink" title="1.连接仿真器（对于TMS280049C直接使用电脑供电即可）"></a>1.连接仿真器（对于TMS280049C直接使用电脑供电即可）</h3><ul><li><strong>点击View—&gt;Target Configurations,进入以下界面：</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113202338478.png"></p><ul><li><strong>右键单击Target Configurations窗口中工程目录下的“TMS320F28035.ccxml”文件（名称是你刚才新建.ccxml文件时的名称)，并选择“Launch Selected Configuration”</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204158990.png">、</p><ul><li><strong>这时CCS会自动进入Debug模式</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204310199.png"></p><ul><li><strong>点击快捷菜单栏的“Connect Target”按下</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204401245.png"></p><ul><li><strong>按钮呈现为按下状态，并且调试按钮都点亮，则仿真器连接成功</strong></li></ul><h3 id="2-程序烧写"><a href="#2-程序烧写" class="headerlink" title="2.程序烧写"></a>2.程序烧写</h3><ul><li><strong>在仿真器连接成功后，点击快捷菜单栏的“Load”按钮，装载程序</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204509070.png"></p><ul><li><p><strong>在弹出的“Load Program”对话框中，点击“Browse project”</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204709163.png"></p></li><li><p><strong>在弹出的对话框中，展开你的工程文件夹，选择“Debug”文件夹下的“xxxx.out”文件，点击“OK”</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204807398.png"></p></li><li><p><strong>点击“Load Program”对话框的“OK”</strong></p></li><li><p><strong>这时出现擦写进度条，等进度条完成就烧写成功啦！</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113204831512.png"></p><h3 id="3-在线仿真"><a href="#3-在线仿真" class="headerlink" title="3.在线仿真"></a>3.在线仿真</h3><ul><li><strong>程序烧写完成后，点击“Resume”按钮可在线运行程序</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113205258457.png"></p><ul><li><strong>若要添加断点（即让程序运行到某处停下），在对应程序行的左侧列双击，出现小圆点即可。</strong></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240113205549773.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TMS320F280049C主控的DSP入门设计（学习笔记二）-TMS280049C评估板下载设置及流程&quot;&gt;&lt;a href=&quot;#TMS320F280049C主控的DSP入门设计（学习笔记二）-TMS280049C评估板下载设置及流程&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程</title>
    <link href="https://lilongxin178.github.io/2023/12/01/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%89%20%20%E6%90%AD%E5%BB%BA%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84CCS%E5%B7%A5%E7%A8%8B/"/>
    <id>https://lilongxin178.github.io/2023/12/01/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%89%20%20%E6%90%AD%E5%BB%BA%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84CCS%E5%B7%A5%E7%A8%8B/</id>
    <published>2023-12-01T06:00:00.000Z</published>
    <updated>2024-01-12T13:02:45.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TMS320F280049C主控的DSP入门设计（学习笔记一）-搭建可移植的CCS工程"><a href="#TMS320F280049C主控的DSP入门设计（学习笔记一）-搭建可移植的CCS工程" class="headerlink" title="TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程"></a>TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​本篇笔记将介绍如何搭建可移植的CCS工程，以便于开发TMS320F280049C主控的DSP入门设计。本篇笔记将详细介绍如何创建CCS工程、添加源文件和库文件、配置编译选项等步骤。</p><h2 id="一、工程文件的复制"><a href="#一、工程文件的复制" class="headerlink" title="一、工程文件的复制"></a>一、工程文件的复制</h2><h3 id="CCS新建空白工程"><a href="#CCS新建空白工程" class="headerlink" title="CCS新建空白工程"></a>CCS新建空白工程</h3><p>​首先打开CCS软件，点击project-&gt;New CCS Project，并按照所需功能自行配置工程名、芯片等信息。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231215164351477.png" alt="图一  CCS项目创建"></p><p>​除此之外，在Project type and tool-chain中配置Output foemat为eabi（ELF）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231215164911602.png" alt="图二  Output foemat设置 "></p><p>​点击Finish后弹出代码编辑器如下：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231215165117052.png" alt="图三  CCS界面展示"></p><p>​此时，我们所选择的工作文件夹目录下应有下列文件：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231215165328941.png" alt="图四  工作文件夹目录"></p><h3 id="拷贝支持文件进入工程文件夹"><a href="#拷贝支持文件进入工程文件夹" class="headerlink" title="拷贝支持文件进入工程文件夹"></a>拷贝支持文件进入工程文件夹</h3><p>​首先，进入C2000Ware的默认下载文件夹，如：D:\ti\c2000\C2000Ware_5_01_00_00（笔者为5.01版本，同时，本文出现的所有文件地址均为笔者自己工作环境下的地址）。并找到：</p><p>​D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\common</p><p>​此文件夹下为F280049的DSP支持文件，接下来对该文件夹内文件进行复制，并粘贴到工作文件夹中。</p><ul><li>首先，将source整个文件夹复制到工作文件夹中。</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216160812216.png" alt="图五  工作文件夹及支持文件夹"></p><ul><li>再将D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\headers\source文件夹下的文件复制到现在工程文件夹下的source中<br><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216161239400.png" alt="图六  headers文件复制"></li><li>将D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\common中的include文件夹全部复制到工程文件夹中。</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216161426275.png" alt="图七  include文件夹复制"></p><ul><li>再将D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\headers\include中的所有文件复制到工作文件夹的include文件夹下</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216162044555.png" alt="图八  headers中include文件复制"></p><ul><li>将D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\common\cmd中的四个cmd文件复制到工程文件夹。</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216162519092.png" alt="图九  cmd文件复制"></p><ul><li><p>接下来对库函数进行复制，首先找到路径地址为D:\ti\c2000\C2000Ware_5_01_00_00\driverlib\f28004x\driverlib的文件夹，该文件夹中含有两个文件夹和.c、.h文件（库函数文件）</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216163005242.png" alt="图十  库函数文件夹"></p></li><li><p>首先，对该文件夹下.h文件进行复制，并粘贴到include文件夹中。</p></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216163321887.png" alt="图十一  .h文件的复制"></p><ul><li>再对.c文件进行复制，此时可以先在工作文件夹中创建文件夹“C_library”，然后将.c文件全部粘贴到该文件夹下。</li></ul><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20231216163630877.png" alt="图十二  .c文件复制"></p><ul><li>最后将剩余的两个文件夹复制到工程文件夹中，到此，库文件复制完毕。</li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216163842097.png" alt="图十三  复制结束后文件夹"></p><h3 id="添加数学运算库及f28004x-headers-nonbios-cmd文件"><a href="#添加数学运算库及f28004x-headers-nonbios-cmd文件" class="headerlink" title="添加数学运算库及f28004x_headers_nonbios.cmd文件"></a>添加数学运算库及f28004x_headers_nonbios.cmd文件</h3><ul><li><p>找到D:\ti\c2000\C2000Ware_5_01_00_00\libraries\math\FPUfastRTS\c28\lib和D:\ti\ccs1250\ccs\tools\compiler\ti-cgt-c2000_22.6.1.LTS\lib（该文件夹为下载CCS后的文件夹），将该文件夹下复制数学运算库到工程文件夹中</p><p><img src="/C:/Users/LLX/AppData/Roaming/Typora/typora-user-images/image-20231216165005039.png" alt="图十四  c28\lib下的数学运算库"></p></li></ul><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216165251866.png" alt="图十五  ti-cgt-c2000_22.6.1.LTS\lib下的数学运算库"></p><ul><li><p>再对f28004x_headers_nonbios.cmd文件进行添加<br>找到D:\ti\c2000\C2000Ware_5_01_00_00\device_support\f28004x\headers\cmd文件夹，对该文件进行复制粘贴。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216165618171.png" alt="图十六  f28004x_headers_nonbios.cmd所在地址"></p></li></ul><h3 id="删除多余文件，整理库文件"><a href="#删除多余文件，整理库文件" class="headerlink" title="删除多余文件，整理库文件"></a>删除多余文件，整理库文件</h3><p>由于使用eabi输出，所以可将ccs中与COFF输出相关的文件都删除掉。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216164213022.png" alt="图十七  debug文件中的coff输出文件"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231216164300490.png" alt="图十八  Release文件中的coff输出文件"></p><h2 id="二-、对文件进行编辑修改"><a href="#二-、对文件进行编辑修改" class="headerlink" title="二 、对文件进行编辑修改"></a>二 、对文件进行编辑修改</h2><p>​1.删除source文件夹f28004x_usdelay.asm文件中函数声明的下划线。这步主要是为了适应eabi输出的需要，也即函数名前不加下划线。<br>​修改前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       .def _F28x_usDelay</span><br><span class="line">       .sect &quot;.TI.ramfunc&quot;</span><br><span class="line"></span><br><span class="line">        .global  __F28x_usDelay</span><br><span class="line">_F28x_usDelay:</span><br><span class="line">        SUB    ACC,#1</span><br><span class="line">        BF     _F28x_usDelay,GEQ    ;; Loop if ACC &gt;= 0</span><br><span class="line">        LRETR</span><br></pre></td></tr></table></figure><p>​修改后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       .def F28x_usDelay</span><br><span class="line">       .sect &quot;.TI.ramfunc&quot;</span><br><span class="line"></span><br><span class="line">        .global  __F28x_usDelay</span><br><span class="line">F28x_usDelay:</span><br><span class="line">        SUB    ACC,#1</span><br><span class="line">        BF     F28x_usDelay,GEQ    ;; Loop if ACC &gt;= 0</span><br><span class="line">        LRETR</span><br></pre></td></tr></table></figure><p>​2.include文件夹下的f28004x_lin.h文件需要修改一个变量名，该变量名可以任意修改，修改原因是命名重复。<br>​修改前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp_16 IDLE:1;   </span><br></pre></td></tr></table></figure><p>​修改后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp_16 LIN_IDLE:1;     </span><br></pre></td></tr></table></figure><p>​3.include文件夹下的f28004x_globalprototypes.h和source文件夹的f28004x_sysctrl.c均需要修改IDLE函数名，该变量名可以任意修改，修改原因也是命名重复。<br>​修改前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void IDLE(void);   //（f28004x_globalprototypes.h）</span><br><span class="line"></span><br><span class="line">IDLE()   //（f28004x_sysctrl.c）</span><br></pre></td></tr></table></figure><p>​修改后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void IIDLE(void);   //（f28004x_globalprototypes.h）</span><br><span class="line"></span><br><span class="line">IIDLE()    //（f28004x_sysctrl.c）</span><br></pre></td></tr></table></figure><h2 id="三、从RAM执行程序时的软件配置"><a href="#三、从RAM执行程序时的软件配置" class="headerlink" title="三、从RAM执行程序时的软件配置"></a>三、从RAM执行程序时的软件配置</h2><p>​此时已经形成了完整的CCS工程文件夹，下面将对工程文件进行索引，而一般debug时希望工程从RAM中进行运行，所以在这里进行RAM中运行的配置。<br>​首先，右键项目浏览器的项目名，打开Properties（属性栏），设置成Debug，这里名字可以任意修改。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231217104654124.png" alt="图十九  Debug设置"></p><p>​后续添加文件路径的时候会涉及到一些缩写，这些缩写在如下位置做了定义：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231217104905507.png" alt="图二十  缩写定义位置"></p><h3 id="添加索引路径"><a href="#添加索引路径" class="headerlink" title="添加索引路径"></a>添加索引路径</h3><p>​右键点击项目浏览器中的项目名，打开Properties（属性）。找到Include Options。按照下图中操作，创建相对路径。直接在对话框中输入 ${PROJECT_ROOT}&#x2F;include，表示工程文件夹中的include文件夹（绝对路径）。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231217105147717.png" alt="图二十一  索引路径添加"></p><h3 id="添加数学库文件路径"><a href="#添加数学库文件路径" class="headerlink" title="添加数学库文件路径"></a>添加数学库文件路径</h3><p>同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。加入下列路径。<br>${PROJECT_ROOT}&#x2F;rts2800_fpu32_eabi.lib</p><p>${PROJECT_ROOT}&#x2F;rts2800_fpu32_fast_supplement_eabi.lib</p><p>其中默认的库文件是libc.a，根据本文开头提到的官网文档，可以直接删除。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231217155149461.png" alt="图二十二  数学库文件路径"></p><p>​快速运行库rts2800_fpu32_fast_supplement.lib是rts2800_fpu32.lib的一个函数子集，它是对rts2800_fpu32.lib中一些函数进行重写，提高运算速度，所以添加是有次序要求，需要进行设置如下：<br>​Link order中添加这两个库，<strong>排序rts2800_fpu32_fast_supplement.lib在前rts2800_fpu32.lib在后</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240112200935295.png" alt="图二十三  Link order的数学库"></p><h3 id="启用FPU和TMU"><a href="#启用FPU和TMU" class="headerlink" title="启用FPU和TMU"></a>启用FPU和TMU</h3><p>同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。 关于编译器–fp_mode的设置等信息可以参考文献[4]的2.3节。<br>目前不推荐启用–idiv_support，在本工程中启用该选项会导致程序无法正确运行。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240112201246312.png" alt="图二十四  FPU/TMU设置"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20240112201328463.png" alt="图二十五  --fp_reassoc"></p><p>四、总结</p><p>​到此，CCS的TMS320F280049C主控模板文件创建完毕。<br>​下节将进行仿真器的配置以及程序下载流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TMS320F280049C主控的DSP入门设计（学习笔记一）-搭建可移植的CCS工程&quot;&gt;&lt;a href=&quot;#TMS320F280049C主控的DSP入门设计（学习笔记一）-搭建可移植的CCS工程&quot; class=&quot;headerlink&quot; title=&quot;TMS320</summary>
      
    
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DSP设计" scheme="https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>关于负电阻的原理及应用的探究</title>
    <link href="https://lilongxin178.github.io/2023/11/30/%E5%85%B3%E4%BA%8E%E8%B4%9F%E7%94%B5%E9%98%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>https://lilongxin178.github.io/2023/11/30/%E5%85%B3%E4%BA%8E%E8%B4%9F%E7%94%B5%E9%98%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%9A%84%E6%8E%A2%E7%A9%B6/</id>
    <published>2023-11-30T02:00:00.000Z</published>
    <updated>2024-01-12T12:40:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于负电阻的原理及应用的探究"><a href="#关于负电阻的原理及应用的探究" class="headerlink" title="关于负电阻的原理及应用的探究"></a>关于负电阻的原理及应用的探究</h1><h2 id="一、负电阻是什么"><a href="#一、负电阻是什么" class="headerlink" title="一、负电阻是什么"></a>一、负电阻是什么</h2><hr><p>一般来说，电压随电流变化的情形在纯电阻电路中可使用微分电阻R进行表示：<br>$$<br>R&#x3D;{dV\over dI<br>}<br>$$<br><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231122133945287.png" alt="图一  隧道二极管伏安特性曲线"></p><p>​由该图可看出，隧道二极管在A-B的阶段是符合前文所说的负微分效应的，但由于隧道二极管的该区域伏安特性并非线性所以该区域并不能称之为负电阻。</p><p>​接下来，我们再对负电阻做更加细致的定义：</p><p>​根据欧姆定律可知电阻二端的电压和电流成正比，其电流-电压关系的图形斜率为正，且会通过原点。</p><p>​那么就可推导理想负电阻其电流-电压关系的图形斜率为负，且会通过原点，因此只在图中的第二和第四象限出现。</p><p>​故可对该理想负电阻进行绘制伏安特性曲线：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231122135127231.png" alt="图二  理想负阻抗伏安特性曲线"></p><p>​由以上推论及实际现象定义负电阻，即可简单定义为理想的负电阻应该为<strong>伏安特性曲线为线性且为斜率为负并经过原点</strong>的一种元件。</p><p>​历史以往研究时有注意到气体放电元件及一些真空管（例如负耗阻性管）会有负阻效应。不过实用且有经济效益的元件一直到固态电子技术普及后才出现。典型的负阻抗电路—负阻抗变换器—是由约翰·林维尔在1953年发明。而典型差动电阻为负值的元件—隧道二极管—则是由江崎玲于奈在1958年发明。</p><h2 id="二、实际负电阻元件构建"><a href="#二、实际负电阻元件构建" class="headerlink" title="二、实际负电阻元件构建"></a>二、实际负电阻元件构建</h2><hr><p>​集成电路兴起后，运算放大器由于其”虚短“”虚断“的特性，为构建一些理论中的器提供了巨大帮助，负电阻也在此应运而生。</p><h3 id="负电阻实际元件"><a href="#负电阻实际元件" class="headerlink" title="负电阻实际元件"></a>负电阻实际元件</h3><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126135548211.png" alt="图三  负阻抗电路"></p><p>​</p><p>该图像为较为典型的负阻抗电路，其阻抗为：<br>$$<br>Z_i &#x3D; {V\over A} &#x3D;-Z<br>$$<br>​现在规定图中电流电压方向为正，由于运算放大器“虚断“的性质，我们可知该电路输入阻抗的绝对值为：</p><p>$$<br>|Z|&#x3D;R_3<br>$$<br>​那再由运放的”虚短“性质可知，可以看出该电路形成了一个放大倍数为两倍的同向放大器，所以当输入端设置电压为V时，输出端电压为2V所以此时R3上的电流在我们设定的状态下应该为-A。所以此时有：<br>$$<br>-A&#x3D;{V\over R}<br>$$<br>​该公式可直接推出该电路阻抗为<br>$$<br>Z_i &#x3D; {V\over A} &#x3D;-Z<br>$$<br>​从本质上来看，我们会发现这里是通过改变电流方向实现的一种模拟负电阻的电路。那我们该如何验证其是否是负电阻呢？接下来进行仿真。</p><h2 id="三、仿真验证"><a href="#三、仿真验证" class="headerlink" title="三、仿真验证"></a>三、仿真验证</h2><hr><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126174749265.png" alt="图四 正负电阻并联仿真"></p><p>​使用 LTspice的直流扫描分析，设置V2从0V开始到2.5V步进0.1V，并给负电阻并联一个正电阻，那么由叠加定理可知，在理想电流源的情况下，正电阻与负电阻上所经过的电流应当相反。那么，开始仿真，测量两个电阻上所经过的电流。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126175748739.png" alt="图五 正负电阻仿真结果"></p><p>​由测试直流分析可以看出，正电阻与负电阻的电流相反，且电流绝对值都为线性上升，所以，在该理想状态下，负电阻能够完美符合我们在前文中的标准。</p><h2 id="四、负电阻应用场景"><a href="#四、负电阻应用场景" class="headerlink" title="四、负电阻应用场景"></a>四、负电阻应用场景</h2><h3 id="4-1-负阻抗缓冲器"><a href="#4-1-负阻抗缓冲器" class="headerlink" title="4.1 负阻抗缓冲器"></a>4.1 负阻抗缓冲器</h3><p>​实际使用运算放大器时，我们往往会遇到运放驱动能力不足的情况，这种情况下，我们总是达不到我们所期望的电路效果。通常，当我们遇到这种情况时，我们通常使用一级跟随器（单位增益缓冲）。在这里我们可以尝试使用另外一种方式，即负阻抗缓冲器。当负载阻抗较小时，我们可以通过计算在输出端并联一负阻抗，此时输出阻抗趋于∞，且电路输出信号不会出现衰减的情况。<br>​与传统跟随器方案相比，该方案具有一重要优点，其使负载阻抗变得很大，几乎消除了负载电阻对电路的影响。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231129202122417.png" alt="图六 负阻抗缓冲器演示"></p><h3 id="4-2-高输入阻抗放大电路"><a href="#4-2-高输入阻抗放大电路" class="headerlink" title="4.2 高输入阻抗放大电路"></a>4.2 高输入阻抗放大电路</h3><p>​在进行运放电路的使用时，我们知道同相放大器具有输入阻抗高的特点，而反相放大器具有运放输入端虚地，电路工作稳定的特定。所以，我们是否能通过负阻抗缓冲器的原理类比出高阻抗的反向放大电路呢？答案是可以实现的，通过反向在输入端并联负阻抗电路，即可有效提高输入阻抗。设计方案如下：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231129203142058.png" alt="图七 高输入阻抗放大电路"></p><h3 id="4-3-负电阻在LC振荡电路中的应用"><a href="#4-3-负电阻在LC振荡电路中的应用" class="headerlink" title="4.3 负电阻在LC振荡电路中的应用"></a>4.3 负电阻在LC振荡电路中的应用</h3><p>​RLC二阶电路的响应具有振荡的特性,特别地,当R &#x3D; 0 时,电路的响应为无阻尼振荡。为了得到无阻尼振荡特性,可用负电阻来“中和”电路中的正电阻。</p><p>​通过修改R4，可观察输出端波形幅值的衰减、稳定、增长的现象。<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231129205756423.png" alt="图八 LC振荡电路"></p><p>​仿真文件地址：<a href="https://github.com/LILONGXIN178/img/blob/master/%E8%B4%9F%E9%98%BB%E6%8A%97LC%E6%8C%AF%E8%8D%A1%E4%BB%BF%E7%9C%9F.ms14">img&#x2F;负阻抗LC振荡仿真.ms14 at master · LILONGXIN178&#x2F;img (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于负电阻的原理及应用的探究&quot;&gt;&lt;a href=&quot;#关于负电阻的原理及应用的探究&quot; class=&quot;headerlink&quot; title=&quot;关于负电阻的原理及应用的探究&quot;&gt;&lt;/a&gt;关于负电阻的原理及应用的探究&lt;/h1&gt;&lt;h2 id=&quot;一、负电阻是什么&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="硬件探讨" scheme="https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"/>
    
    
    <category term="运放的运用" scheme="https://lilongxin178.github.io/tags/%E8%BF%90%E6%94%BE%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于Typora的Markdown使用</title>
    <link href="https://lilongxin178.github.io/2023/11/26/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Markdown%E4%BD%BF%E7%94%A8/"/>
    <id>https://lilongxin178.github.io/2023/11/26/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Markdown%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-26T04:00:00.000Z</published>
    <updated>2024-01-12T12:40:40.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Typora的Markdown使用"><a href="#基于Typora的Markdown使用" class="headerlink" title="基于Typora的Markdown使用"></a>基于Typora的Markdown使用</h1><hr><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><hr><p>​Word文件是目前我们日常生活中较为常用的文字文件，但我们会发现我们在使用中经常出现排版变化的问题。那为了将排版进行统一规范，我们可能需要一种统一的软件或者文件格式来进行规范。</p><p>​那我们会发现，有这样的一种标记语言——Markdown。</p><p>​那么既然我们想要去使用Markdown进行文件的书写，我们自然需要一个编辑器工具对其进行编辑使用。学习之初，有我的学长向我推荐了Typora这款编辑器，而我本人也对这款编辑器较为熟悉，所以，本篇博文将基于Typora对Markdown的使用进行探讨。</p><h2 id="二、Typora的快捷键设置"><a href="#二、Typora的快捷键设置" class="headerlink" title="二、Typora的快捷键设置"></a>二、Typora的快捷键设置</h2><hr><h3 id="2-1-常用快捷键"><a href="#2-1-常用快捷键" class="headerlink" title="2.1 常用快捷键"></a>2.1 常用快捷键</h3><ul><li>加粗： <code>Ctrl + B</code></li><li>撤销： <code>Ctrl + Z</code></li><li>字体倾斜 ：<code>Ctrl+I</code></li><li>下划线：<code>Ctrl+U</code></li><li>多级标题： <code>Ctrl + 1~6</code></li><li>有序列表：<code>Ctrl + Shift + [</code></li><li>无序列表：<code>Ctrl + Shift + ]</code></li><li>降级快捷键 ：<code>Tab</code></li><li>升级快捷键：<code>Shift + Tab</code></li><li>插入链接： <code>Ctrl + K</code></li><li>插入公式： <code>Ctrl + Shift + M</code></li><li>行内代码： <code>Ctrl + Shift + K</code></li><li>插入图片： <code>Ctrl + Shift + I</code></li><li>返回Typora顶部：<code>Ctrl+Home</code></li><li>返回Typora底部 ：<code>Ctrl+End</code></li><li>创建表格 ：<code>Ctrl+T</code></li><li>选中某句话 ：<code>Ctrl+L</code></li><li>选中某个单词 ：<code>Ctrl+D</code></li><li>选中相同格式的文字 ：<code>Ctrl+E</code></li><li>搜索: <code>Ctrl+F</code></li><li>搜索并替换 ：<code>Ctrl+H</code></li><li>删除线 ：<code>Alt+Shift+5</code></li><li>引用 ：<code>Ctrl+Shift+Q</code></li><li>生成目录：<code>[TOC]+Enter</code></li></ul><h3 id="2-2-部分功能演示-介绍"><a href="#2-2-部分功能演示-介绍" class="headerlink" title="2.2  部分功能演示&#x2F;介绍"></a>2.2  部分功能演示&#x2F;介绍</h3><h4 id="2-2-1-目录"><a href="#2-2-1-目录" class="headerlink" title="2.2.1 目录"></a>2.2.1 目录</h4><p>​输入[TOC]加Enter生成目录。该目录可随用户使用时自动更新，并且具有跳转功能，使用较为简单。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126093735797.png"></p><h4 id="2-2-2-段落"><a href="#2-2-2-段落" class="headerlink" title="2.2.2 段落"></a>2.2.2 段落</h4><p>​使用换行键[Enter]可以建立新的一行,而使用<code>Shift</code>+<code>Enter</code>可以创建一个比段落间距更小的行间距。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126094245026.png"></p><h4 id="2-2-3-代码块"><a href="#2-2-3-代码块" class="headerlink" title="2.2.3 代码块"></a>2.2.3 代码块</h4><p>​使用快捷键Ctrl + Shift + K，创建代码块。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello,python!&quot;&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-2-4-数学公式"><a href="#2-2-4-数学公式" class="headerlink" title="2.2.4 数学公式"></a>2.2.4 数学公式</h4><p>打开Typora选择数学模块</p><ul><li>点击“段落”—&gt;“公式块”（不推荐）</li><li>快捷键Ctrl+Shift+m       (快捷方式)</li><li>“$$”+回车                     （Markdown语法）</li></ul><p> 以上三种方式都能打开数学公式的编辑栏。</p><p>示例：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126094951006.png"></p><h4 id="2-2-5-上下标及高亮使用"><a href="#2-2-5-上下标及高亮使用" class="headerlink" title="2.2.5 上下标及高亮使用"></a>2.2.5 上下标及高亮使用</h4><p>​进入偏好设置：</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126095114568.png"></p><p>​勾选以上的拓展语法，并进行使用。</p><h2 id="三、Typora图床设置"><a href="#三、Typora图床设置" class="headerlink" title="三、Typora图床设置"></a>三、Typora图床设置</h2><hr><p>​     使用Typora时如果不使用图床，我们插入的图片将会保存至本地，那么当我们发往博客或CSDN时就无法直接显示图片。因此我们需要设置一个图床，将图片上传至图床。这里我们可以使用<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>+<a href="https://so.csdn.net/so/search?q=Gitee&spm=1001.2101.3001.7020">Gitee</a>的方式，无需任何费用且上传速度也不错，唯一缺点就是上传再Gitee上私密性不强。</p><h3 id="3-1-Gitee使用及配置"><a href="#3-1-Gitee使用及配置" class="headerlink" title="3.1 Gitee使用及配置"></a>3.1 Gitee使用及配置</h3><p>​Gitee和GitHub都是较为常用的代码托管平台，和GitHub相比最大的都是就是其访问速度在国内环境下相对较快。所以我们将我们的图床远程仓库设置在Gitee上。<br>​Gitee地址：*<a href="https://link.zhihu.com/?target=https://gitee.com/">https://gitee.com/</a>*</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125303689.png"></p><p><strong>新建仓库：</strong></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125341324.png"></p><p>​此处仓库名自己可任意填写。下面两个标出的红色框中的信息直接按照图中所示配置。</p><p><strong>创建私人令牌：</strong></p><p>​回到主页，然后点击自己的头像，选择账号设置。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125434995.png"></p><p>​打开后，找到私人令牌</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125528364.png"></p><p>​进入后点击生成新令牌<img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126090555648.png"></p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126090632411.png"></p><p>​简单对项目进行简述，并勾选图中所勾选选项。并输入密码进行验证。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126091222223.png"></p><p>​将私人令牌的token进行复制保存。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126091351166.png"></p><h3 id="3-2-Picgo安装下载及使用"><a href="#3-2-Picgo安装下载及使用" class="headerlink" title="3.2 Picgo安装下载及使用"></a>3.2 Picgo安装下载及使用</h3><p>​PicGo是一款开源免费且支持多平台。</p><p>​下载并打开Picgo进行安装。安装完成后进入主界面。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125604731.png"></p><p>​此处可以选择链接格式（markdown、HTML、URL、UBB、Custom等），另外也需要对图床进行设置，为了使用Gitee作为图床，我们应当先进入插件设置来添加Gitee。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126091909225.png"></p><p>下面在图床设置中对Gitee进行配置。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126092257130.png"></p><h3 id="3-3-Typora设置"><a href="#3-3-Typora设置" class="headerlink" title="3.3 Typora设置"></a>3.3 Typora设置</h3><p>​进入Typora，打开“文件”进入“偏好设置”</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125634886.png"></p><p>​在该设置中选择其用以下几种功能，并将上传服务选择为Picgo（app），并将应用程序地址填入绝对路径。</p><p><img src="https://raw.githubusercontent.com/LILONGXIN178/img/master/image-20231126125702215.png"></p><p>​现在只要我们在typora中粘贴任意一张图片，Gicgo就会自动将图片上传到我们的gitee仓库中，肥肠的方便好用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Typora的Markdown使用&quot;&gt;&lt;a href=&quot;#基于Typora的Markdown使用&quot; class=&quot;headerlink&quot; title=&quot;基于Typora的Markdown使用&quot;&gt;&lt;/a&gt;基于Typora的Markdown使用&lt;/h1&gt;&lt;hr&gt;
</summary>
      
    
    
    
    <category term="工具使用" scheme="https://lilongxin178.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Markdown" scheme="https://lilongxin178.github.io/tags/Markdown/"/>
    
    <category term="Typora" scheme="https://lilongxin178.github.io/tags/Typora/"/>
    
  </entry>
  
</feed>
