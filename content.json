{"meta":{"title":"小李工作站","subtitle":"小李工作站","description":"","author":"工程小李","url":"https://lilongxin178.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2023-11-24T11:16:27.807Z","comments":true,"path":"404.html","permalink":"https://lilongxin178.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2023-11-24T11:11:53.000Z","updated":"2023-11-24T11:12:07.187Z","comments":true,"path":"about/index.html","permalink":"https://lilongxin178.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-24T08:52:39.000Z","updated":"2023-11-24T08:53:04.706Z","comments":true,"path":"categories/index.html","permalink":"https://lilongxin178.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-11-24T11:12:23.000Z","updated":"2023-11-24T11:12:41.803Z","comments":true,"path":"contact/index.html","permalink":"https://lilongxin178.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-11-24T11:13:30.000Z","updated":"2023-11-24T11:13:40.864Z","comments":true,"path":"friends/index.html","permalink":"https://lilongxin178.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-24T11:11:23.000Z","updated":"2023-11-24T11:11:40.723Z","comments":true,"path":"tags/index.html","permalink":"https://lilongxin178.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Stateflow 建模基础（1）","slug":"Stateflow 建模基础（1）","date":"2023-12-14T06:00:00.000Z","updated":"2024-02-13T04:20:32.278Z","comments":true,"path":"2023/12/14/Stateflow 建模基础（1）/","permalink":"https://lilongxin178.github.io/2023/12/14/Stateflow%20%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/","excerpt":"","text":"Stateflow基础（1）一、简介及Stateflow的特点1.简介​ Stateflow是有限状态机(Finite State Machine，FSM)的图形实现工具，它可以用于解决事件驱动系统中复杂的逻辑问题。Stateflow 通过开发 FSM 和流程图的设计环境扩展Simulink的功能，在系统中可以用图形化的工具来实现各个状态之间的迁移。​ Stateflow 图表采用图形建模的方式构建层次化的、并行工作的状态和它们之间由事件驱动的逻辑迁移关系。Stateflow 在传统状态图的基础上扩展了控制流、MATLAB 函数、图形函数、真值表、临时运算符、直接事件广播，并可以集成用户自编 C 代码，而且通过Stateflow Coder 可以为 Stateflow 状态图模型自动生成C代码。 2.特点Stateflow的主要特点如下: (1)提供层次化、可并行的、具有明确执行语义的建模语言元素，并以自然易懂的形式来描述复杂逻辑系统。 (2)使用流程图定义图形化函数，使用 MATLAB 函数进行编程操作，使用真值表完成表格形式的处理。 (3)采用临时逻辑调度状态迁移与事件 (4)支持Mealy和Moore有限状态机。 (5)可集成用户自定义输人输出变量的C代码 (6)支持向量、矩阵、总线信号和定点数据类型。 (7)可进行静态模型检查，包括病态定义的真值表。 (8)可动态检测迁移冲突、死循环、状态不一致、数据范围错误和溢出问题 (9)仿真进行中以动画显示状态图的运行并记录数据，以便于对系统的理解和调试。 (10)集成了一个调试器，采用图形化断点进行单步调试，在调试时浏览其中的数据 二、构造并运行Stateflow图（设计过零比较器）1.打开 Stateflow 编辑器​ Stateflow 编辑器是一个图形环境，用于设计状态转移图、流程图、状态转移表和真值表。 要建立周期性或连续时间 Simulink 算法的条件、基于事件和基于时间的逻辑模型，请使用 [sfnew] 函数创建一个可在 Simulink 模型中作为模块进行仿真的 Stateflow 图。在 MATLAB 命令提示符处，输入： 1sfnew rectify % 在simulink中创建一个仿真图表 Simulink 创建一个名为 rectify 的模型，其中包含一个空的 Stateflow Chart 模块。要打开 Stateflow 编辑器，请双击图模块。 要为 MATLAB 应用程序设计可重用的状态机和时序逻辑，请使用 edit 函数创建可作为 MATLAB 对象执行的独立 Stateflow 图。在 MATLAB 命令提示符处，输入： 1edit rectify.sfx % 创建图表执行作为Matlab对象 如果文件 rectify.sfx 不存在，Stateflow 编辑器将创建名为 rectify 的空图。 ​ Stateflow 编辑器的主要组件是图画布、对象选项板和符号窗格。 图画布是一个绘图区域，可以在其中通过组合状态、转移和其他图形元素来创建图。 在画布的左侧有一个对象选项板，其中显示了一组可向图中添加图形元素的工具。 在画布的右侧有一个符号窗格，您可以用它向图添加新的数据、事件和消息并解析任何未定义或未使用的符号。 PS:在构造 Stateflow 图后，您可以将其内容复制到另一个具有不同执行模式的图中。例如，您可以构造在 MATLAB 中执行的图，并将其内容复制到在 Simulink 中进行仿真的图中。 2.添加状态和转移 在对象选项板中，点击状态图标并将指针移至图画布。将出现具有默认转移的状态。要放置该状态，请点击画布上的某个位置。在文本提示中，输入状态名称 On 和状态动作 y = x。 添加另一个状态。右键点击并拖动 On 状态。蓝色图形提示可以帮助您水平或垂直对齐状态。新状态的名称变为 Off。双击该状态并将状态动作修改为 y = 0。 重新对齐两个状态并在两个状态之间的空白处停留片刻出现蓝色转移提示指示进行连接。 双击每个转移并输入适当的转移条件 x&lt;t0 或 x&gt;=t0。条件出现在方括号内。（选择添加转移表达式） 5.结果如下图： 3.解析未定义的符号​ 在执行图之前，必须定义图中使用的每个符号并指定其作用域（例如，输入数据、输出数据或局部数据）。 ​ （1）打开符号窗格。​ （2）在符号窗格中，点击解析未定义的符号 ​ （3）由于阈值 t0 在仿真过程中不会更改，因此将其作用域更改为常量数据。在类型列中，点击 t0 旁边的数据类型图标，然后选择常量数据。​ （4）设置阈值 t0 的值。在值列中，点击 t0 旁边的空白输入框，并输入值 0。​ （5）保存Stateflow 图。 4.进行仿真​ （1）要返回到 Simulink 编辑器，请在画布顶部的浏览器栏中点击 Simulink 模型的名称：rectify。如果浏览器栏不可见，请点击对象选项板顶部的隐藏&#x2F;显示资源管理器栏图标 。 ​ （2）执行以下操作以将信源添加到模型中： 从 Simulink Sources 库中，添加一个 Sine Wave (Simulink) 模块。 双击 Sine Wave 模块并将采样时间设置为 0.2。 将 Sine Wave 模块的输出连接到 Stateflow 图的输入。 将信号标记为 x。 ​ （3）添加一个示波器。 ​ （4）保存 Simulink 模型。 ​ （5）开始仿真。 ​ 可以看到此处小于0的数据被滤除了。","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Simulink建模基础（2）","slug":"Simulink建模基础（2）","date":"2023-12-12T06:00:00.000Z","updated":"2024-02-08T05:55:51.657Z","comments":true,"path":"2023/12/12/Simulink建模基础（2）/","permalink":"https://lilongxin178.github.io/2023/12/12/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/","excerpt":"","text":"Simulink建模基础（2）三、数学表达式模型搭建技巧​ 本节对公式：$$y(t)&#x3D;A*e^{-t\\over a}+{K\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau)e^{t\\over a}d\\tau+{\\beta\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$的数学表达式进行建模。 1.先将结构进行剖析分解（1）将系统划分为几个子系统$$y(t)&#x3D;Function1+Function2+Function3$$ ​ 所以，有$$Function1&#x3D;A*e^{-t\\over a}$$ $$Function2&#x3D;{K\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau)e^{t\\over a}d\\tau$$ $$Function3&#x3D;{\\beta\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$ （2）此时再将子系统划分为各个小块。如：$$Function1&#x3D;block1+block2$$ $$Function2 &#x3D; block2 * block3 * block4$$ $$Function3&#x3D; block2 *block5 *block6$$ ​ 所以可得出$$block1&#x3D;A$$ $$block2&#x3D;e^{-t\\over a}$$ $$block3&#x3D;{K\\over\\alpha}$$ $$block4&#x3D;\\int_0^tx(\\tau)e^{t\\over a}d\\tau$$ $$block5&#x3D;{\\beta\\over\\alpha}$$ $$block6&#x3D;e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$ 2.开始进行建模（1）创建上文所使用的六个模块​ 如图，先创建Function1： ​ 再创建Function2，以及Function3 （2）建立子系统 ​ 将三个子系统建立完成后： ​ （3）进行三个子系统的连接 3.模型仿真及测试（1）添加测试用例及显示设备​ 添加一个正弦信号模块作为测试用例并按默认设置。 ​ 添加一个示波器模块作为显示设备。 ​ 双击该模块，在打开后界面的左上角，点击“视图”-&gt;”配置属性”，打开下图界面。 ​ 设置完成后，为下图样式： （2）对参数进行设置​ 1.按照上文参数设置，对该建模内未定义的参数进行定义并赋值。 ​ 2.设置仿真停止时间 ​ 3.设置求解器类型（变步长）；并选择ode23的求解器。 ​ 4.进行仿真 四、Simulink仿真的各种波形显示方式1.普通示波器Scope ​ 调用方式：库浏览器中搜索Scope，拖出使用即可。 2.Dashboard Scope示波器（1）添加Dashboard Scope模块,即在模型的空白处单击选中该模型然后键人“dash”接着选中Dashboard Scope （2）连接Dashboard Scope模块即双击 Dashboard Scope模块，打开模块参数对话框接着选中需要显示的信号，这些信号将出现在模块参数对话框中。 3.仿真数据检查器（Data Inspector）​ 为了在一个页面中显示多个信号的波形，或对某个&#x2F;多个信号的多次测试进行记录，以优化模型中的参数等可使用 Data Inspector。如同时观察x(t)、y(t)、Functionl、Function2和Function3等信号。 ​ （1）右击需要的信号选择“记录所选信号” ​ （2）将所需信号全部按上述操作进行处理 ​ （3）找到已经选择的信号，再次右击打开仿真数据检查器。 ​ （4）对信号在此进行简单的归位排序，以便查看。 ​ （5）记录多次仿真结果。利用该记录功能可对比在不同参数条件下的输出波形，从而选择模型中更符合实际的参数。 4.逻辑分析仪(Logic Analyzer)。​ 对于选中的信号可以一次性将其波形显示出来，特别适用于逻辑关系比较明显的系统其操作方法为:选择 Logic Analyzer 选项即可打开逻辑分析仪对话框。","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Simulink建模基础（1）","slug":"Simulink建模基础（1）","date":"2023-12-11T06:00:00.000Z","updated":"2024-02-06T06:17:34.082Z","comments":true,"path":"2023/12/11/Simulink建模基础（1）/","permalink":"https://lilongxin178.github.io/2023/12/11/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/","excerpt":"","text":"Simulink建模基础（1）一、简介​ Simulink是动态和嵌人式等系统的建模与仿真工具，也是模型设计的基础。对于机电航空航天、信号处理、自动控制、通信、音视频处理等众多领域，Simulink 提供了交互式可视化开发环境和可定制的模块库，对系统进行建模、仿真与调试等;并可实现与 Stateflow有限状态机的无缝连接，扩展对复杂系统的建模能力。​ 通过Simulink模块库自带的1000多个预定义模块基本上可快速地创建基于MCU器件应用的系统模型。运用层次化建模、数据管理、子系统定制等手段，即使是复杂的嵌入式MCU应用系统，也能轻松地完成简明精确的模型描述。 ​ 主要内容： ​ Simulink基本操作 Simulink模块库简介 Simulink建模新方法介绍 物理建模简介 二、Simulink基本操作2.1模块库和编辑窗口2.1.1 打开Simulink的起始页​ 在MATLAB的命令行窗口中输人Simulink指令或单击MATLAB工具栏上的Simulink图标，可打开Simulink的起始页。 2.1.2 打开模型编辑窗口​ 创建一个新的模型，首先要打开一个模型编辑窗口。可以通过单击“Simulink的起始页”上所需要的模板，这里选择空白模型(Blank Model)来打开编辑窗口。 2.1.3 打开Simulink库浏览器查看Simulink模块库中包含的子库​ 单击图3.2工具栏上的“库浏览器”图标，可查看Simulink 模块库所包含的子库。 2.2 建模示例2.2.1 有物理含义或微分方程创建模型 1.求解负载电阻R上消耗功率的数学表达式​ 根据欧姆定律，该电路的电流i可表示为：$$i&#x3D;{V_S\\over R_s+R_L}$$​ 则负载电阻R上消耗的功率为$$P&#x3D;i^2*R_L$$ 2.搭建Simulink 模型(1)模型所需模块分析​ 该模型可由3个 Constant 常数模块、1个Add 加法模块、1个 Divide 除法模块1个Product乘法模块1个Math Function 数学函数模块和1个Display 显示模块来表达。 (2)创建一个Simulink模型。​ D单击工具栏上的图标打开Simulink起始页新建一个空白的Simulink模型并另存为自己的工作文件夹中。​ 从Simulink 模块库(Commonly Used Blocks、Math Operations 和 Sinks)中添加Constant模块、Add模块、Divide模块、Math Function模块、Product 模块和 Display模块等。 (3)搭建好的模型 2.3参数设置1.在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器： 2.选择Parameters,选中你要定义的变量位置，点击┇按钮 3.按照下图进行数据的创建： 4.在该界面进行参数的设置 5.回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存6.进入保存好的Matlab文件，得到如图所示的配置文件。 ​ 在这里可以对每个参数的值，类型等进行修改。 7.在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量.Value，如图所示。 8.点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了 9.选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入.m文件名,这样每次直接运行simlink文件时，会自动加载一次.m文件 2.4 模型仿真​ 先对模型中各参数进行赋值，赋值后在simulink中，点击工具栏中的开始图标进行仿真。结果如下：","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Matlab2022a离线安装Embedded Coder Support Package TI C2000","slug":"Matlab2022a离线安装Embedded Coder Support Package TI C2000","date":"2023-12-10T06:00:00.000Z","updated":"2024-01-31T06:31:54.964Z","comments":true,"path":"2023/12/10/Matlab2022a离线安装Embedded Coder Support Package TI C2000/","permalink":"https://lilongxin178.github.io/2023/12/10/Matlab2022a%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Embedded%20Coder%20Support%20Package%20TI%20C2000/","excerpt":"","text":"Matlab2022a离线安装Embedded Coder Support Package TI C2000一、了解Embedded Coder Support Package TI C2000​ 德州仪器 （TI） C2000 处理器的嵌入式编码器®支持包使您能够在 TI C2000™ MCU 上运行 Simulink® 模型。Embedded Coder 会自动为您的算法和设备驱动程序模块生成 C 代码，这些代码可直接在目标硬件上运行。该支持包可用于不同控制应用（包括电机控制和电源转换）的快速原型制作和生产工作流程。 ​ 内容 从 Simulink 模型生成代码并部署到 TI C2000 硬件 用于 ADC、PWM、SPI、I2C、串行、SDFM、CAN、硬件中断、eCAP、QEP、比较器、DAC 等的设备驱动程序模块。 支持多核处理器 支持控制律加速器 （CLA） 具有处理器在环 （PIL）、监控和调谐（外部模式）、SD 卡记录和实时分析的验证功能 IQMath 的代码替换库 电机控制和功率转换应用实例 ​ 我们可以看到该工具性能十分强大，下面我们来对其进行离线安装。 二、离线安装Embedded Coder Support Package TI C20001、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。2、安装TI开发套件及SDK 3.下载supportsoftwaredownloader_r2022b_win64.exe4.安装并进入登录界面登录（没有的话直接去Matlab官网申请）5.选择自己安装的Matlab版本 6.选择自己需要安装的支持包 7.选择默认安装路径 8.下载完成后会自动打开以下文件夹 9.打开readme，并复制当前文件夹路径​ readme此处为Windows系统安装方式。 10.按照readme的方式进行安装​ win+r打开cmd命令行 ​ 先进入自己matlab默认安装文件夹–&gt;例如D:\\MATLAB\\R2022a\\bin\\win64 ​ 再使用readme中的名令打开supportsoftware.exe，进入安装。 11.跟着系统提示安装即可。12.安装完成后，找到MATLAB附加功能管理器， 13.选择自己需要的支持包 逐步安装即可 13.打开一个示例并生成代码 14.打开CCS进行编译 ​ 编译成功","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程","slug":"TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程","date":"2023-12-02T06:00:00.000Z","updated":"2024-01-13T13:00:44.335Z","comments":true,"path":"2023/12/02/TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程/","permalink":"https://lilongxin178.github.io/2023/12/02/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%89%20%20TMS280049C%E8%AF%84%E4%BC%B0%E6%9D%BF%E4%B8%8B%E8%BD%BD%E8%AE%BE%E7%BD%AE%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"","text":"TMS320F280049C主控的DSP入门设计（学习笔记二） TMS280049C评估板下载设置及流程一、仿真器配置​ 对于280049C，其官方的LaunchPad开发板使用了XDS110仿真器的两线调试模式，而官方的ControlCard使用的是XDS100V2仿真器，开发时需要注意区分，并分别设置。本文以采用两线制调试的XDS110仿真器为例进行设置。​ 右键点击工程名，选择New—&gt;TargetConfiguration File，File name取名任意，这里可取名为LaunchPad.ccxml，点击Finish。 ​ 点击第三步的操作，进入如下图界面，选择JTAG_2_PIN调试模式。 二、配置FLASH执行​ 当代码调试完毕后，需将代码烧录到FLASH中进行固化，使其掉电程序依旧储存在FLASH中。使DSP可以脱离仿真器运行。 1.修改至FLASH模式 然后重复与RAM中执行类似的配置，具体包括以下几步： 添加索引路径 添加数学库文件路径 启用FPU和TMU 定义_LAUNCHXL_F280049C 文件管理 2.声明_FLASH和code_start为了使程序正确的从flash启动，编程时通常有一些特殊的代码需要运行(通常TI都已经在库函数中提供)。为了确保这些代码能够正确编译，执行本步骤。 3.添加cmd文件​ 将FLASH相关的cmd加进来。 三、程序烧写与仿真1.连接仿真器（对于TMS280049C直接使用电脑供电即可） 点击View—&gt;Target Configurations,进入以下界面： 右键单击Target Configurations窗口中工程目录下的“TMS320F28035.ccxml”文件（名称是你刚才新建.ccxml文件时的名称)，并选择“Launch Selected Configuration” 、 这时CCS会自动进入Debug模式 点击快捷菜单栏的“Connect Target”按下 按钮呈现为按下状态，并且调试按钮都点亮，则仿真器连接成功 2.程序烧写 在仿真器连接成功后，点击快捷菜单栏的“Load”按钮，装载程序 在弹出的“Load Program”对话框中，点击“Browse project” 在弹出的对话框中，展开你的工程文件夹，选择“Debug”文件夹下的“xxxx.out”文件，点击“OK” 点击“Load Program”对话框的“OK” 这时出现擦写进度条，等进度条完成就烧写成功啦！ 3.在线仿真 程序烧写完成后，点击“Resume”按钮可在线运行程序 若要添加断点（即让程序运行到某处停下），在对应程序行的左侧列双击，出现小圆点即可。","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程","slug":"TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程","date":"2023-12-01T06:00:00.000Z","updated":"2024-01-12T13:02:45.048Z","comments":true,"path":"2023/12/01/TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程/","permalink":"https://lilongxin178.github.io/2023/12/01/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%89%20%20%E6%90%AD%E5%BB%BA%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84CCS%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"TMS320F280049C主控的DSP入门设计（学习笔记一） 搭建可移植的CCS工程 前言​ 本篇笔记将介绍如何搭建可移植的CCS工程，以便于开发TMS320F280049C主控的DSP入门设计。本篇笔记将详细介绍如何创建CCS工程、添加源文件和库文件、配置编译选项等步骤。 一、工程文件的复制CCS新建空白工程​ 首先打开CCS软件，点击project-&gt;New CCS Project，并按照所需功能自行配置工程名、芯片等信息。 ​ 除此之外，在Project type and tool-chain中配置Output foemat为eabi（ELF） ​ 点击Finish后弹出代码编辑器如下： ​ 此时，我们所选择的工作文件夹目录下应有下列文件： 拷贝支持文件进入工程文件夹​ 首先，进入C2000Ware的默认下载文件夹，如：D:\\ti\\c2000\\C2000Ware_5_01_00_00（笔者为5.01版本，同时，本文出现的所有文件地址均为笔者自己工作环境下的地址）。并找到： ​ D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common ​ 此文件夹下为F280049的DSP支持文件，接下来对该文件夹内文件进行复制，并粘贴到工作文件夹中。 首先，将source整个文件夹复制到工作文件夹中。 再将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\source文件夹下的文件复制到现在工程文件夹下的source中 将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common中的include文件夹全部复制到工程文件夹中。 再将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\include中的所有文件复制到工作文件夹的include文件夹下 将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common\\cmd中的四个cmd文件复制到工程文件夹。 接下来对库函数进行复制，首先找到路径地址为D:\\ti\\c2000\\C2000Ware_5_01_00_00\\driverlib\\f28004x\\driverlib的文件夹，该文件夹中含有两个文件夹和.c、.h文件（库函数文件） 首先，对该文件夹下.h文件进行复制，并粘贴到include文件夹中。 再对.c文件进行复制，此时可以先在工作文件夹中创建文件夹“C_library”，然后将.c文件全部粘贴到该文件夹下。 最后将剩余的两个文件夹复制到工程文件夹中，到此，库文件复制完毕。 添加数学运算库及f28004x_headers_nonbios.cmd文件 找到D:\\ti\\c2000\\C2000Ware_5_01_00_00\\libraries\\math\\FPUfastRTS\\c28\\lib和D:\\ti\\ccs1250\\ccs\\tools\\compiler\\ti-cgt-c2000_22.6.1.LTS\\lib（该文件夹为下载CCS后的文件夹），将该文件夹下复制数学运算库到工程文件夹中 再对f28004x_headers_nonbios.cmd文件进行添加找到D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\cmd文件夹，对该文件进行复制粘贴。 删除多余文件，整理库文件由于使用eabi输出，所以可将ccs中与COFF输出相关的文件都删除掉。 二 、对文件进行编辑修改​ 1.删除source文件夹f28004x_usdelay.asm文件中函数声明的下划线。这步主要是为了适应eabi输出的需要，也即函数名前不加下划线。​ 修改前： 12345678 .def _F28x_usDelay .sect &quot;.TI.ramfunc&quot; .global __F28x_usDelay_F28x_usDelay: SUB ACC,#1 BF _F28x_usDelay,GEQ ;; Loop if ACC &gt;= 0 LRETR ​ 修改后： 12345678 .def F28x_usDelay .sect &quot;.TI.ramfunc&quot; .global __F28x_usDelayF28x_usDelay: SUB ACC,#1 BF F28x_usDelay,GEQ ;; Loop if ACC &gt;= 0 LRETR ​ 2.include文件夹下的f28004x_lin.h文件需要修改一个变量名，该变量名可以任意修改，修改原因是命名重复。​ 修改前： 1bp_16 IDLE:1; ​ 修改后： 1bp_16 LIN_IDLE:1; ​ 3.include文件夹下的f28004x_globalprototypes.h和source文件夹的f28004x_sysctrl.c均需要修改IDLE函数名，该变量名可以任意修改，修改原因也是命名重复。​ 修改前： 123void IDLE(void); //（f28004x_globalprototypes.h）IDLE() //（f28004x_sysctrl.c） ​ 修改后： 123void IIDLE(void); //（f28004x_globalprototypes.h）IIDLE() //（f28004x_sysctrl.c） 三、从RAM执行程序时的软件配置​ 此时已经形成了完整的CCS工程文件夹，下面将对工程文件进行索引，而一般debug时希望工程从RAM中进行运行，所以在这里进行RAM中运行的配置。​ 首先，右键项目浏览器的项目名，打开Properties（属性栏），设置成Debug，这里名字可以任意修改。 ​ 后续添加文件路径的时候会涉及到一些缩写，这些缩写在如下位置做了定义： 添加索引路径​ 右键点击项目浏览器中的项目名，打开Properties（属性）。找到Include Options。按照下图中操作，创建相对路径。直接在对话框中输入 ${PROJECT_ROOT}&#x2F;include，表示工程文件夹中的include文件夹（绝对路径）。 添加数学库文件路径同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。加入下列路径。${PROJECT_ROOT}&#x2F;rts2800_fpu32_eabi.lib ${PROJECT_ROOT}&#x2F;rts2800_fpu32_fast_supplement_eabi.lib 其中默认的库文件是libc.a，根据本文开头提到的官网文档，可以直接删除。 ​ 快速运行库rts2800_fpu32_fast_supplement.lib是rts2800_fpu32.lib的一个函数子集，它是对rts2800_fpu32.lib中一些函数进行重写，提高运算速度，所以添加是有次序要求，需要进行设置如下：​ Link order中添加这两个库，排序rts2800_fpu32_fast_supplement.lib在前rts2800_fpu32.lib在后 启用FPU和TMU同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。 关于编译器–fp_mode的设置等信息可以参考文献[4]的2.3节。目前不推荐启用–idiv_support，在本工程中启用该选项会导致程序无法正确运行。 四、总结 ​ 到此，CCS的TMS320F280049C主控模板文件创建完毕。​ 下节将进行仿真器的配置以及程序下载流程。","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"关于负电阻的原理及应用的探究","slug":"关于负电阻的原理及应用的探究","date":"2023-11-30T02:00:00.000Z","updated":"2024-01-12T12:40:23.861Z","comments":true,"path":"2023/11/30/关于负电阻的原理及应用的探究/","permalink":"https://lilongxin178.github.io/2023/11/30/%E5%85%B3%E4%BA%8E%E8%B4%9F%E7%94%B5%E9%98%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%9A%84%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"关于负电阻的原理及应用的探究一、负电阻是什么 一般来说，电压随电流变化的情形在纯电阻电路中可使用微分电阻R进行表示：$$R&#x3D;{dV\\over dI}$$ ​ 由该图可看出，隧道二极管在A-B的阶段是符合前文所说的负微分效应的，但由于隧道二极管的该区域伏安特性并非线性所以该区域并不能称之为负电阻。 ​ 接下来，我们再对负电阻做更加细致的定义： ​ 根据欧姆定律可知电阻二端的电压和电流成正比，其电流-电压关系的图形斜率为正，且会通过原点。 ​ 那么就可推导理想负电阻其电流-电压关系的图形斜率为负，且会通过原点，因此只在图中的第二和第四象限出现。 ​ 故可对该理想负电阻进行绘制伏安特性曲线： ​ 由以上推论及实际现象定义负电阻，即可简单定义为理想的负电阻应该为伏安特性曲线为线性且为斜率为负并经过原点的一种元件。 ​ 历史以往研究时有注意到气体放电元件及一些真空管（例如负耗阻性管）会有负阻效应。不过实用且有经济效益的元件一直到固态电子技术普及后才出现。典型的负阻抗电路—负阻抗变换器—是由约翰·林维尔在1953年发明。而典型差动电阻为负值的元件—隧道二极管—则是由江崎玲于奈在1958年发明。 二、实际负电阻元件构建 ​ 集成电路兴起后，运算放大器由于其”虚短“”虚断“的特性，为构建一些理论中的器提供了巨大帮助，负电阻也在此应运而生。 负电阻实际元件 ​ 该图像为较为典型的负阻抗电路，其阻抗为：$$Z_i &#x3D; {V\\over A} &#x3D;-Z$$​ 现在规定图中电流电压方向为正，由于运算放大器“虚断“的性质，我们可知该电路输入阻抗的绝对值为： $$|Z|&#x3D;R_3$$​ 那再由运放的”虚短“性质可知，可以看出该电路形成了一个放大倍数为两倍的同向放大器，所以当输入端设置电压为V时，输出端电压为2V所以此时R3上的电流在我们设定的状态下应该为-A。所以此时有：$$-A&#x3D;{V\\over R}$$​ 该公式可直接推出该电路阻抗为$$Z_i &#x3D; {V\\over A} &#x3D;-Z$$​ 从本质上来看，我们会发现这里是通过改变电流方向实现的一种模拟负电阻的电路。那我们该如何验证其是否是负电阻呢？接下来进行仿真。 三、仿真验证 ​ 使用 LTspice的直流扫描分析，设置V2从0V开始到2.5V步进0.1V，并给负电阻并联一个正电阻，那么由叠加定理可知，在理想电流源的情况下，正电阻与负电阻上所经过的电流应当相反。那么，开始仿真，测量两个电阻上所经过的电流。 ​ 由测试直流分析可以看出，正电阻与负电阻的电流相反，且电流绝对值都为线性上升，所以，在该理想状态下，负电阻能够完美符合我们在前文中的标准。 四、负电阻应用场景4.1 负阻抗缓冲器​ 实际使用运算放大器时，我们往往会遇到运放驱动能力不足的情况，这种情况下，我们总是达不到我们所期望的电路效果。通常，当我们遇到这种情况时，我们通常使用一级跟随器（单位增益缓冲）。在这里我们可以尝试使用另外一种方式，即负阻抗缓冲器。当负载阻抗较小时，我们可以通过计算在输出端并联一负阻抗，此时输出阻抗趋于∞，且电路输出信号不会出现衰减的情况。​ 与传统跟随器方案相比，该方案具有一重要优点，其使负载阻抗变得很大，几乎消除了负载电阻对电路的影响。 4.2 高输入阻抗放大电路​ 在进行运放电路的使用时，我们知道同相放大器具有输入阻抗高的特点，而反相放大器具有运放输入端虚地，电路工作稳定的特定。所以，我们是否能通过负阻抗缓冲器的原理类比出高阻抗的反向放大电路呢？答案是可以实现的，通过反向在输入端并联负阻抗电路，即可有效提高输入阻抗。设计方案如下： 4.3 负电阻在LC振荡电路中的应用​ RLC二阶电路的响应具有振荡的特性,特别地,当R &#x3D; 0 时,电路的响应为无阻尼振荡。为了得到无阻尼振荡特性,可用负电阻来“中和”电路中的正电阻。 ​ 通过修改R4，可观察输出端波形幅值的衰减、稳定、增长的现象。 ​ 仿真文件地址：img&#x2F;负阻抗LC振荡仿真.ms14 at master · LILONGXIN178&#x2F;img (github.com)","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"运放的运用","slug":"运放的运用","permalink":"https://lilongxin178.github.io/tags/%E8%BF%90%E6%94%BE%E7%9A%84%E8%BF%90%E7%94%A8/"}],"author":"工程小李"},{"title":"基于Typora的Markdown使用","slug":"基于Typora的Markdown使用","date":"2023-11-26T04:00:00.000Z","updated":"2024-01-12T12:40:40.399Z","comments":true,"path":"2023/11/26/基于Typora的Markdown使用/","permalink":"https://lilongxin178.github.io/2023/11/26/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Markdown%E4%BD%BF%E7%94%A8/","excerpt":"","text":"基于Typora的Markdown使用 一、简介 ​ Word文件是目前我们日常生活中较为常用的文字文件，但我们会发现我们在使用中经常出现排版变化的问题。那为了将排版进行统一规范，我们可能需要一种统一的软件或者文件格式来进行规范。 ​ 那我们会发现，有这样的一种标记语言——Markdown。 ​ 那么既然我们想要去使用Markdown进行文件的书写，我们自然需要一个编辑器工具对其进行编辑使用。学习之初，有我的学长向我推荐了Typora这款编辑器，而我本人也对这款编辑器较为熟悉，所以，本篇博文将基于Typora对Markdown的使用进行探讨。 二、Typora的快捷键设置 2.1 常用快捷键 加粗： Ctrl + B 撤销： Ctrl + Z 字体倾斜 ：Ctrl+I 下划线：Ctrl+U 多级标题： Ctrl + 1~6 有序列表：Ctrl + Shift + [ 无序列表：Ctrl + Shift + ] 降级快捷键 ：Tab 升级快捷键：Shift + Tab 插入链接： Ctrl + K 插入公式： Ctrl + Shift + M 行内代码： Ctrl + Shift + K 插入图片： Ctrl + Shift + I 返回Typora顶部：Ctrl+Home 返回Typora底部 ：Ctrl+End 创建表格 ：Ctrl+T 选中某句话 ：Ctrl+L 选中某个单词 ：Ctrl+D 选中相同格式的文字 ：Ctrl+E 搜索: Ctrl+F 搜索并替换 ：Ctrl+H 删除线 ：Alt+Shift+5 引用 ：Ctrl+Shift+Q 生成目录：[TOC]+Enter 2.2 部分功能演示&#x2F;介绍2.2.1 目录​ 输入[TOC]加Enter生成目录。该目录可随用户使用时自动更新，并且具有跳转功能，使用较为简单。 2.2.2 段落​ 使用换行键[Enter]可以建立新的一行,而使用Shift+Enter可以创建一个比段落间距更小的行间距。 2.2.3 代码块​ 使用快捷键Ctrl + Shift + K，创建代码块。示例如下： 1print(&quot;hello,python!&quot;&quot;) 2.2.4 数学公式打开Typora选择数学模块 点击“段落”—&gt;“公式块”（不推荐） 快捷键Ctrl+Shift+m (快捷方式) “$$”+回车 （Markdown语法） 以上三种方式都能打开数学公式的编辑栏。 示例： 2.2.5 上下标及高亮使用​ 进入偏好设置： ​ 勾选以上的拓展语法，并进行使用。 三、Typora图床设置 ​ 使用Typora时如果不使用图床，我们插入的图片将会保存至本地，那么当我们发往博客或CSDN时就无法直接显示图片。因此我们需要设置一个图床，将图片上传至图床。这里我们可以使用PicGo+Gitee的方式，无需任何费用且上传速度也不错，唯一缺点就是上传再Gitee上私密性不强。 3.1 Gitee使用及配置​ Gitee和GitHub都是较为常用的代码托管平台，和GitHub相比最大的都是就是其访问速度在国内环境下相对较快。所以我们将我们的图床远程仓库设置在Gitee上。​ Gitee地址：*https://gitee.com/* 新建仓库： ​ 此处仓库名自己可任意填写。下面两个标出的红色框中的信息直接按照图中所示配置。 创建私人令牌： ​ 回到主页，然后点击自己的头像，选择账号设置。 ​ 打开后，找到私人令牌 ​ 进入后点击生成新令牌 ​ 简单对项目进行简述，并勾选图中所勾选选项。并输入密码进行验证。 ​ 将私人令牌的token进行复制保存。 3.2 Picgo安装下载及使用​ PicGo是一款开源免费且支持多平台。 ​ 下载并打开Picgo进行安装。安装完成后进入主界面。 ​ 此处可以选择链接格式（markdown、HTML、URL、UBB、Custom等），另外也需要对图床进行设置，为了使用Gitee作为图床，我们应当先进入插件设置来添加Gitee。 下面在图床设置中对Gitee进行配置。 3.3 Typora设置​ 进入Typora，打开“文件”进入“偏好设置” ​ 在该设置中选择其用以下几种功能，并将上传服务选择为Picgo（app），并将应用程序地址填入绝对路径。 ​ 现在只要我们在typora中粘贴任意一张图片，Gicgo就会自动将图片上传到我们的gitee仓库中，肥肠的方便好用。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://lilongxin178.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lilongxin178.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://lilongxin178.github.io/tags/Typora/"}],"author":"工程小李"}],"categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"},{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"},{"name":"工具使用","slug":"工具使用","permalink":"https://lilongxin178.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"},{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"运放的运用","slug":"运放的运用","permalink":"https://lilongxin178.github.io/tags/%E8%BF%90%E6%94%BE%E7%9A%84%E8%BF%90%E7%94%A8/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lilongxin178.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://lilongxin178.github.io/tags/Typora/"}]}