{"meta":{"title":"小李工作站","subtitle":"小李工作站","description":"","author":"工程小李","url":"https://lilongxin178.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2023-11-24T11:16:27.807Z","comments":true,"path":"404.html","permalink":"https://lilongxin178.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-24T08:52:39.000Z","updated":"2023-11-24T08:53:04.706Z","comments":true,"path":"categories/index.html","permalink":"https://lilongxin178.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-11-24T11:11:53.000Z","updated":"2023-11-24T11:12:07.187Z","comments":true,"path":"about/index.html","permalink":"https://lilongxin178.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-24T11:11:23.000Z","updated":"2023-11-24T11:11:40.723Z","comments":true,"path":"tags/index.html","permalink":"https://lilongxin178.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-11-24T11:12:23.000Z","updated":"2023-11-24T11:12:41.803Z","comments":true,"path":"contact/index.html","permalink":"https://lilongxin178.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-11-24T11:13:30.000Z","updated":"2023-11-24T11:13:40.864Z","comments":true,"path":"friends/index.html","permalink":"https://lilongxin178.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"晶振基础知识","slug":"晶振基础知识","date":"2024-08-15T06:00:00.000Z","updated":"2024-10-22T09:06:42.624Z","comments":true,"path":"2024/08/15/晶振基础知识/","permalink":"https://lilongxin178.github.io/2024/08/15/%E6%99%B6%E6%8C%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"晶振基础知识晶振振动方式石英晶体单元的振动类型分为弯曲振动，扩张振动，表面切变振动和厚度切变振动。基频和泛音可以在任何类型的谐振器中工作。最常用的是基频，但对于厚度型器件也常用泛音。 PS:晶振基频是指晶体振荡器产生的基本频率，而泛音是晶体振荡器产生的高频谐波。 频率-温度特性​ 定义：频率温度特性是指环境温度在规定的范围内按预定的方式改变时，其输出频率产生的相对变化特性 ​ 石英产品大多作为电路元件用于频率选择和&#x2F;或频率控制，因此器件的频率-温度特性是最重要的参数。这种百万分之一(ppm)级频率-温度特性的稳定性是石英频率器件的另一个优点，是LCR离散分量振荡电路无法在大规模生产中实现的。 晶体谐振器的等效电路 C0:并联电容 C1：动态电容 L1：动态电感 R1：动态电阻 C0并联电容：两个电极间形成的寄生电容。 L1动态等效电感：代表机型振动的惯性。 C1动态等效电容：代表晶振的弹性。 R1动态等效电阻：代表电路的损耗。 谐振频率​ 一般来说，有三对谐振频率，分别为【“串联谐振频率（fs）”，“并联谐振频率（fp）”】，【“谐振频率”（fr），“反谐振”频率（fa）】，【“最大和最小总导纳定位”频率（fm和fn）】 ​ 根据晶振的等效模型，将电阻先忽略不计（由于反馈系统的影响，晶振最终稳定频率不受电阻影响，故此处忽略电阻简化阻抗表达式），即可得到以下的晶振阻抗表达式：$$Z&#x3D;\\frac{\\mathrm{j}}{\\mathrm{w}}\\times\\frac{\\mathrm{w}^2\\times\\mathrm{L}_1\\times\\mathrm{C}_1-1}{(\\mathrm{C}_0+\\mathrm{C}_1)-\\mathrm{w}^2\\times\\mathrm{L}_1\\times\\mathrm{C}_1\\times\\mathrm{C}_0}$$​ 此时可以得出阻抗与频率的关系： ​ fs即为Z&#x3D;0时的串联谐振频率，表达式为：$$\\mathrm{F_{s}}&#x3D;\\frac{1}{2\\pi\\sqrt{L_1C_1}}$$​ 而fp即为Z&#x3D;∞时（分母为0的点）的并联谐振频率，表达式为：$$\\mathrm{F_{p}&#x3D;F_{s}\\sqrt{1+\\frac{C_1}{2C_0}}}$$​ fs和fp之间的区域（图中的阴影区域）是并联谐振的区域。在这一区域晶振工作在并联谐振状态，并且在此区域晶振呈电感特性，从而带来了相当于180 °的相移。相对来说，对于评估晶振性能，其fs和fp更为重要，所以下文也以fs和fp为重点进行术语的介绍及推导。 晶振的各项术语(1)标称频率及其公差或校准精度 ​ 晶体谐振器的频率通常用兆赫(MHz)或千赫(kHz)来指定。正常频率是我们期望从适当匹配的晶体振荡电路中得到的输出频率。在环境温度下(参考25℃)，真实设备的频率与标称频率有一定的偏差。中心频率与标称频率的偏差，作为设备的一个参数，用一个最大值来指定，以百分数(%)或百万分率(ppm)表示。​ 计算公式为:$$频偏&#x3D;【（实际频率-标称频率）&#x2F;标称频率*10^{6}】ppm$$(2)负载电容 ​ 负载电容CL是从谐振器两端观察电路时振荡器所展示的负载。负载电容形式上与谐振器串联或并联。在并联负载情况下CL的存在会影响并联谐振频率，并联谐振频率fL由。公式如下所示：$$f_L&#x3D;f_s\\sqrt{1+C_1&#x2F;2(Co+CL)}$$​ 由于负载电容是以并联的形式连接到晶振上，所以，可计算出上表达式。 （3）频率-温度稳定性 频率-温度稳定性表示的在标准温度环境下(通常25℃)由工作温度变化引起的频率偏差。该参数的曲线体现了频率偏差(单位%或ppm)和工作温度与参考温度(25℃)间偏差的关系。石英器件的温度稳定性取决于切割方式、振动方式和石英毛坯的尺寸。此外，该偏差值与晶体谐振器的工作温度范围、负载电容和驱动功率有关。 （4）等效串联电阻(ESR) 串联支路中出现的电阻R1可以在串联谐振频率下测量，此时C1和L1的影响相互抵消，R1表示晶体单元和封装的机械性损失。 （5）运动电容C1和运动电感L1 C1与L1这两个参数与串联谐振频率fs相关，如图10所示，在谐振器设计和表征中fs是一个非常确定的参数。工业标准中只规定了C1的值，L1可以由下方公式推导得出。与振荡电路中通常使用的电容相比，C1的值非常小，可以由晶片和电极的材料和几何参数来评估。$$L_1&#x3D;\\frac1{4\\pi^2{f_s}^2C_1}$$（6）静态电容Co(在支路中) Co是一个静态电容，无论晶体是否工作都存在，Co的值可以在很低的频率(小于或约1.0 MHz)测得，计算公式如下，其中A为电极面积，d为切片厚度，e为相应晶体切片的介电常数。在实际应用中，Co不仅包括电镀石英裸片的静态电容，还包括导电结合材料的电容和封装外壳本身的电容$$C_0&#x3D;\\varepsilon_{ij}^s.\\frac Ad$$（7）驱动功率 谐振器的驱动功率是以纳瓦、微瓦或毫瓦为单位的功率消耗量。运行功率是保证正常启动并保持稳态振荡的合适功率范围。驱动功率应设置在最低功率，以避免长期运行带来的频率漂移和晶体断裂。一般来说，产品越小，在不损坏石英谐振器长期使用的情况下，驱动器功率应该越低。一般来说，驱动级别从10 uW到100 uW对于大多数应用已经足够好了。 （8）质量因子-Q 作为谐振器，质量因子Q值是一个非常重要的参数。在规格中，指定了空载和有负载情况下的Q值。空载Q，或机械Q，可以表示为，R1是出现在串联支路的电阻。负载值取决于负载电路。$$Q&#x3D;\\frac{2 \\pi f_sL_1}{R_1}&#x3D;\\frac{1}{2 \\pi f_sC_1R_1}$$（9）晶振牵引度 ​ 晶振的牵引度是指工作在正常并联谐振区的晶振频率的变化率。这也用于衡量随负载电容变化而导致的频率变化，负载电容的减少会导致频率的增加，反之负载电容的增加会导致频率的减小。晶振的牵引度表达式如下：$$\\text{Pullability}_{(\\text{PPM&#x2F;pF})}&#x3D;\\frac{\\text{C}_1\\times10^6}{2\\times\\left(\\text{C}0+\\text{C}{\\text{L}}\\right)^2}$$（10）老化 老化是指工作频率在指定时间段内的相对 变化，在指定时间段内以百万分率(ppm)表示。这种频率变化率通常是指数性质的。老化的第一周老化率是最高的，之后缓慢下降。通常情况下，老化率可以由85℃下放置一个月，或25摄氏度下放置一年测量得出。老化速率取决于许多因素:密封方法、完整性、制造工艺、材料类型、操作温度和频率。 （11）存储温度范围 该参数规定了晶体在非工作状态下可以存储或暴露的最低和最高温度。晶体在非工作状态下，长时间处于规定的存储温度范围内，再次在规定的工作温度范围内工作时，晶体的各项参数指标应当符合规格书的规定。 皮尔斯晶体振荡器的计算方式皮尔斯晶体振荡器有低功耗、低成本及良好的稳定性等特点，因此常见于应用中。 $\\begin{aligned}&amp;\\text{Inv: 内部反相放大器。}\\&amp;\\text{Q: 石英或陶瓷晶振。}\\&amp;\\text{RF: 内部反馈电阻。}\\&amp;\\text{RExt: 外部限流电阻,限制反相器输出电流。}\\&amp;\\text{CL1和CL2:两个外部负载电容。}\\&amp;\\text{CS: 寄生电容: PCB所线,OSC IN和OSC OUT管脚之间的效杂散电容}\\end{aligned}$ 皮尔斯晶体振荡器设计 1、反馈电阻RF ​ RF一般来说是内嵌在芯片内的。它的作用是让反相器作为一个放大器来工作。​ Vin和Vout之间增加的反馈电阻使放大器形成反馈，以使其成为闭环的系统，并在工作初期使反相器工作在线性区。该放大器（也可以叫做频率选择器）放大了晶振的正常工作区域内（Fs与Fp之间）的噪声(例如晶振的热噪声)，该噪声从而引发晶振起振（同时由于反馈环路的存在，其不会通过振荡导致输出无限增长）。在某些情况下，起振后去掉反馈电阻RF，振荡器仍可以继续正常工作。 2、负载电容CL ​ 负载电容CL是指连接到晶振上的终端电容。CL值取决于外部电容器CL1和CL2，杂散电容Cs。CL值一般可从芯片手册中查阅到。​ 调整外部电容器CL1和CL2，使振荡电路实际的负载电容等于晶振制造商标定的负载值CL参数（晶振规格书一般会提供），可以获得标定的振荡频率。​ 计算公式如下：$$\\mathrm{C_L&#x3D;\\frac{C_{L1}\\times C_{L2}}{C_{L1}+C_{L2}}+C_s}$$​ 举个栗子：​ 如果晶振规格书手册中CL ＝15pF，并假定Cs &#x3D; 5pF，则匹配电容CL1，CL2有：$$\\mathrm{C_{L}-C_{s}&#x3D;\\frac{C_{L1}\\times C_{L2}}{C_{L1}+C_{L2}}&#x3D;10pF.Thatis:C_{L1}&#x3D;C_{L2}&#x3D;20~pF}$$3、振荡器的增益裕量 ​ 由上述推导，我们可得知该振荡器设计可看作一个闭环的线性系统，根据自动控制原理的理论，闭环的系统的稳定性、增益等受到增益裕量的影响；​ 按照ST的AN2867中的描述，增益裕度应等于：$$gain_{margin}&#x3D;\\frac{g_m}{g_{mcrit}}$$ $$\\mathrm{g_{mcrit}&#x3D;4\\times ESR\\times(2\\pi F)^2\\times(C_0+C_L)^2}$$ ​ 而此处$\\mathrm{g_{m}}$为芯片手册内的值，故，可进行计算得出增益值。 ​ 但ST手册相对来说偏向单片机结构进行设计运算，而在希华和村田的技术文档中，均以负阻的形式进行运算，此时，我们需对晶振的负载电容进行计算：$$R_L&#x3D;R_1\\left(1+C_0&#x2F;C_L\\right)^{2}$$​ ​ 为了在恒定频率下保持稳定的振荡，它必须具有足够的负电阻（|-R|）以补偿晶体的电阻。将电阻“VR”串联到晶体单元中，并确保振荡开始或停止。 电路的近似负电阻是将有效电阻“RL”与振荡开始时或停止时的最大电阻“VR”相加得到的值，在逐渐使VR值变大后。负电阻（-R）的最佳值是R1的3~5倍。 如果负电阻 （-R） 太小，可能会使晶体不稳定。 参考资料： 希华 (yoketant.com.tw) 振荡裕量 测量方法的基础知识 | 晶体谐振器的基础知识 | 村田制作所 (murata.com.cn)","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"author":"工程小李"},{"title":"阻容感基础----电阻专题","slug":"阻容感基础-电阻专题","date":"2024-06-20T06:00:00.000Z","updated":"2024-10-23T08:57:49.147Z","comments":true,"path":"2024/06/20/阻容感基础-电阻专题/","permalink":"https://lilongxin178.github.io/2024/06/20/%E9%98%BB%E5%AE%B9%E6%84%9F%E5%9F%BA%E7%A1%80-%E7%94%B5%E9%98%BB%E4%B8%93%E9%A2%98/","excerpt":"","text":"阻容感基础—-电阻专题前言基础关于虚数先看这样一个表达式x² &#x3D; 1，它有两个解：1和-1；那么若有方程x² &#x3D; -1呢？其在实数范围内无解，那将其进行简单的数学变换，将x² &#x3D; -1，改写成1* x* x &#x3D; -1。那么此时，x便成为了一个“步骤”，从1经过两次变换变为了-1。唉，那是不是可以将从1到-1这个过程看成角度的变换。 那么在如下图中包含两个正交轴的坐标系上，就能够实现1到-1的转变。如下左图所示，构成的正交坐标平面称为“复平面”，其横轴为实数（Real dimension），纵轴为虚数（Imaginary dimension），并将x² &#x3D; -1的解用字母i表示，其特指逆时针旋转90°。那如果要顺时针旋转90°呢？那就乘以-i；而且乘以两次-i，结果同乘以两次i一样，都得到了-1。 对于阻、容、感的阻抗，我们知道电阻：R是实数部分（能量消耗），而容抗：Xc&#x3D;1jωC，和感抗XL&#x3D;jωL是虚数部分（能量的虚消耗，就是没有能量消耗，能量只是做着储存&#x2F;释放的工作），所以阻抗同样可以用复数平面来表示，任何器件阻抗都能写成实部与虚部之和：Z &#x3D; R +j*Im （公式中的“j”即虚数“i”）；对于容抗来说是顺时针旋转90°，感抗是逆时针旋转了90°（电容与电感的阻抗特性对偶）。 我们将阻抗R用幅值和相角进行重构： 阻抗的幅值：|Z| &#x3D; √(R²+I²m) （复数的模） 阻抗的相角： &#x3D; tan⁻¹(Im&#x2F;R) rad （复数的幅角） 通过对上述阻抗幅值的公式，可从理论上得到电容器自谐振时（由于Xc &#x3D; -XL，那么Im &#x3D; 0）的阻抗为电容器的ESR。 电子电路物理参数​ 电子电路学有4个基本物理量：电压V，磁通量φ，电流I，电量Q；而这4个物理量构成了电路的理论基础，我们平时所使用的阻、容、感器件特性均从这些基本量中推理得到。由电磁学理论可知V &amp; φ和Q &amp; I之间的如下关系： 根据麦克斯韦方程组的第三方程-法拉第定律：曲面磁通量的变化率等于感应生成电场的环流（记住：磁场跟电流是强相关的）；简单表述即：感应电场等于单位时间磁通量的变化，即： V&#x3D;dφ&#x2F;dt或dφ&#x3D;V*dt。 电磁学上将：单位时间（t）内通过导体任一横截面的电量（q）叫做电流强度（I），即I&#x3D;dq&#x2F;dt；或dq&#x3D;i*dt。 电阻：从本质来说是载流子（自由电子是载流子的一种，当然在半导体中，空穴也是另外一种载流子）在受电场作用而位移过程中受到的阻力。 ——在理想情况下，电场力作用于自由电子，使电子朝电场的反向加速运动，根据牛顿第二定律，自由电子应当一直被加速（只要时间足够长，就可以将电子速度达到接近光速），电流随时间持续增大；但实际上电流到达一个定值后就不会再增大，说明存在一个“摩擦力”反抗着电子的加速；而“摩擦力”主要来自于晶体晶格的热振动，晶体中的杂质、位错、点缺陷会使电子受到散射，而散射事件使得电子失去动能并改变运动方向，从而失去前进方向上的速度分量，这就是金属有电阻的原因。 ——对于横截面恒定材料的电阻R &#x3D; ρ*Len&#x2F;A，R：电阻值； ρ：体电阻率；Len：材料长度；A：材料横截面积。后续在“电阻器原理专题”中详细讲解。 电容：由两个导体构成，任何两个导体之间都有一定的电容量，其本质是对两个导体在一定电压下存储电荷能力的度量；在一定电压下，能够存储的电荷越多，则这对导体的电容量就越大。 ——只要是两个不短路的导体，且加电压后会有电荷积累，那么它们之间就会有电容；一定要记住这个条件，后面不同电容的出现方式会超出想象，这是唯一遵循的准则。后续在“电容器原理” 以及“信号完整性基础专题”中详细讲解。 ——C&#x3D;ε0εrA&#x2F;d，C：电容量；ε0：真空介电常数；εr：相对介电常数；A：电极面积；d：电极距离。 电感必须需要一个有一个的圈圈么？其实并非如此，判断标准有点抽象？抽象就对了： 1，电感周围会形成闭合磁力线圈。 2，电感量是导体电流1A时周围的磁力线匝数（Wb）。 3，周围磁力线匝数改变时导体两端产生感应电压（感应电动势）。——电感器涉及到了电场与磁场能量的转换，理解上更加复杂一点，后续“电感器原理”分析。 ——任何有电流流过的导体都有电感（自感），与导体的几何结构及磁导率强相关；电感将是我们后续大部分专题中的绝对主角，同学们需要学会欣赏它的精彩演绎，从而有更深入的认知。后续在“电感器原理”以及“信号完整性基础专题”中详细讲解。 电容要发挥其作用，就必须电极两端的电荷数量（电势差）发生变化，如果电容两个电极电荷数量不变（电极两端电压保持不变），那么电容就相当于一根导线。 同理，电感要产生作用，必须流过电感的电流发生变化，如果电流没有变化，那么电感也相当于是一根导线。 理想电阻器、电容器、电感器的特性我们已经知道了电阻器是阻碍电流通过的作用；而根据能量守恒定律，电阻器将电能转化为了热能；如果用一个字来描述电阻器的特性，那就是：阻（肉盾）。在电阻器的两端加电压会产生一定的电流，而这部分电能（I2*R）被电阻所消耗，所以大手一挥给它定个性吧：电阻器是一种耗能元件。 我们通过两种电压模式来观察电阻器的特性：直流电压和交流电压； 在直流电压条件下，通过电阻器的电流是恒定的。 在交流电压条件下，通过电阻器的电流跟随着电压变化而变化，而电阻器阻值保持不变（理想电阻器不随电压&#x2F;电流而变化），所以电压和电流保持线性关系：I&#x3D;V&#x2F;R。 2，理想电容器电容器是一种储能元件，将能量以静电场能（电场能量）的形式进行储存。理想电容器两端电压不能突变，我们同样通过两种电压模式来看电容器的特性：直流电压和交流电压； 在电容器两端加直流电压（中间串有电阻R）时： 1，上电瞬间，电容器在电路中呈现低阻抗状态，对电容器进行快速（大电流）充电，电容器两端等效于短路； 2，随后电容器两端电压非线性（指数曲线）增加，RC充电时间常数为τ &#x3D; R*C；——RC充电时间常数时电容器两端电压达到0.63倍外加电压。 3，电容器两端电压等于外加直流电压（理论上电容器两端电压永远小于外加直流电压，即永远充不满），此时流经电容器的电流为 0，电容器等效于开路； 4，此时电源释放的电能，以静电场能的形式（电容器两端增加电荷）储存在电容里。 在电容器两端加交流电压，电流相位超前电压相位90°。 电容器阻抗Xc&#x3D;1&#x2F; jωC；通过电容器阻抗的计算，我们知道电容器阻抗与电容器容值及信号频率成反比，从而直观的得到电容器实际应用：大电容器用于“隔直通交”，而小电容器用于“通高阻低”。 3，理想电感器电感器也是一种储能元件，它并不消耗电场能量，而是将电场能量转换成磁场能量，以磁场能量形式储存起来；流经理想电感器电流不能突变，通过电感的电流会产生自感电动势，其变化趋势与外加电压变化的方向相反（负反馈）。 通过两种电压模式来看电感器的特性：直流电压和交流电压； 在电感器两端加直流电压（中间串有电阻R）时： 上电瞬间，电感器产生强大自感电动势与外加电压相等（后续在“电感器原理”中再来具体扯一扯这一特性）、方向相反，在电路中呈高阻抗状态（断路）；随着电流增加速率慢慢减小，自感电动势也随之减小；直到电流趋于稳定时，自感电动势为0，电感器在电路中相当于短路；此时电源释放的能量完全转化为电感器的磁场能量。在电感器两端加交流电压，自感电动势落后于电流相位90°，外加电压超前于电流相位90°，自感电动势与外加交流电压相位完全相反；电感器阻抗XL&#x3D;jωL；通过电感器阻抗的计算，我们知道了电感器阻抗与电感器感值及信号频率成正比，从而直观的得到电感器的应用：大电感器用于“通直阻交”，小电感器用于“通低阻高”，与电容器刚好相反。 关于阻抗​ 电阻器是耗能元件而电容器和电感器是储能元件。所以电阻是真实的消耗电场能量：阻抗的实数部分，而电容和电感是假的电磁能量“消耗”：是阻抗的虚数部分。所以我们将阻抗Z的实部称为：电阻，虚部称为：电抗。电阻对直流电的阻碍作用我们称为电阻；电容的对交流电的阻碍作用（电抗）称为：容抗；电感的对交流电的阻碍作用（电抗）称为：感抗。当然，我们可以将电阻、容抗、感抗统统都称为阻抗。 电阻器模型1，电阻器理想模型​ 电阻器是电子系统中最常用的元件，对于理想电阻器来说，其频响特性应该是对于所有的频率下的电阻值都不变，而且相角为0°。$$Z&#x3D;R\\angle0^{\\circ}$$ 2，电阻器实际模型​ 然而实际电阻器在高频时的阻值必然会偏离其理想阻值，因为真实的电阻器必然不会只有电阻特性本身，而是由电阻、复杂的寄生电容和寄生电感所组成；虽然寄生电容值和寄生电感都非常小，但在高频时具有明显的电感或电容效应（即电感或电容对电阻器的阻抗影响较大）。实际模型如下： ​ 根据上图可得电阻的实际等效阻抗为：$$Z_{real}&#x3D;\\frac{(j\\omega L+R)*\\frac{1}{j\\omega C}}{(j\\omega L+R)+\\frac{1}{j\\omega C}}$$​ 化简可得：$$Z_{real}&#x3D;\\frac{j\\omega L+R}{(1-\\omega^2LC)+j\\omega RC} \\$$​ 实际电阻器的阻抗和频率曲线，有两个节点，分别为$$f1&#x3D;\\frac1{2\\pi RC} \\f2&#x3D;\\frac1{2\\pi \\sqrt{LC}} \\$$​ 在频率小于f1时，呈现电阻特性，在f1和f2之间，呈现电容减少阻抗，频率大于f2时，呈现电感增加阻抗的特性。 f1和f2分别对应RC滤波器的截止频率点和容抗和感抗相等时的频率点。 ​ 寄生电容和寄生电感与电阻器本身的器件结构、封装、尺寸等都有很大的关系，如果想要尽量减小寄生电容、电感，最好使用小封装、贴片的电阻器。​ 在大多数数字电路中，我们可以将金属厚膜贴片电阻器（例如常用的0402封装电阻器）看成一个“理想电阻器”来应用 3，电阻器特性及参数（1）电阻率​ 材料 “体阻率” 的概念：是材料的固有特性，用来表示材料电阻特性的物理量，反映了材料对电流阻碍作用的属性。 与材料尺寸无关。——它表明的是这种物质本身的导电特性，但这并不是说不会受到环境的影响，例如温度。 材料导电性能越差，其体阻率越高。那我们如何通过电阻率来计算电阻值呢？对于横截面恒定材料的电阻值，可以用如下公式计算：R &#x3D; ρ*Len&#x2F;A；R：电阻值； ρ：体电阻率；Len：材料长度；A：材料横截面积。对电阻的另一个描述是电导，它描述了导体导电性能的物理量，即对于某一种导体允许电流通过它的容易性的量度。它是电阻的倒数G&#x3D;1&#x2F;R，单位是S（西门子）。相应的也就有电导率：用来描述物质中电荷流动难易程度的参数；用字母σ表示，σ&#x3D;1&#x2F;ρ，单位是：S&#x2F;m。——电阻表现的是材料对电流导通的阻力，而电导表现的是材料对电流的导通容易性； （2）电阻温度系数​ 电阻温度系数（Temperature Coefficient of Resistance）：表示电阻当温度改变1℃时，电阻值的相对变化，单位为ppm&#x2F;℃；​ 平均电阻温度系数定义式：TCR(平均)&#x3D; [(R2-R1)&#x2F;R1]*[1&#x2F;(T2-T1)]。 （3）电阻额定功率​ 电阻额定功率：该参数体现了电阻器的散热能力，与电阻器的封装、尺寸相关；如下为片状电阻的尺寸及对应封装功耗。 稳态功率降额：在相应工作温度下的降额，即器件符合曲线所规定的环境温度下功率的降额，采用P&#x3D;V²&#x2F;R公式进行计算；是器件长期稳定的工作条件 瞬态功耗降额：电阻器脉冲功耗和稳态功率的转换曲线不同，需要查询转换曲线，将瞬态功率转换为稳态功率，然后在此基础上降额。 （4）额定电压​ 额定电压：电阻器的工作电压一般有两个，需要选择其小值作为电路实际工作电压； 由阻值和额定功率换算出的电压。——该电压由电阻器封装的最大散热功耗（例如：0402封装，1&#x2F;16w功耗）决定：最大连续工作电压和最大脉冲电压。 电阻器的封装耐压。——该电压由电阻器封装所能承受的最大击穿电压决定。 （5）老化系数​ 老化系数：电阻器在额定功率的长期负荷下，阻值相对变化的百分数，表示电阻器寿命长短的参数。 （6）电压系数​ 电压系数：在规定的电压范围内，电压每变化1V，电阻器阻值的相对变化量。 （7）噪声​ 噪声：产生于电阻器中的一种不规则的电压起伏，包括热噪声和电流噪声两部分。 热噪声：由于导体内部不规则的电子自由运动，使导体任意两点的电压不规则变化，属于电阻器的本征噪声。 电流噪声：来源于电阻器内部结构不连续性和非完整性，与电阻器类型有非常大关系。 4，电阻器分类从不同角度，可以对电阻器的种类作不同划分，如下图所示： （1）按用途分类（这种分类方式侧重于电阻的实际电路设计应用） 通用型：适应一般技术要求的电阻，功率在0.06W-1W之间，阻值在1Ω-22MΩ之间，允许误差为1%~10%之间；——应用于一般的数、模电路：分压、阻抗匹配、上下拉等应用。 精密型：高精密度及高稳定性（低温漂：低至2ppm&#x2F;℃）电阻，功率一般不大于2W；阻值在0.01Ω~20MΩ之间，允许误差小至0.01%；相对普通电阻有更高的精度、长期稳定性、温度系数小的特性；­——应用于精密仪器：医疗、量测、电信设备等，汽车电子电路，高精度电压采样电路，电源电流&#x2F;功耗监测（金属箔电阻器）电路等。 功率型：又被称为发热电阻&#x2F;负荷电阻，在电路中主要起到降压和限流的作用，通常具有较高额定功率，功率可达3KW以上；主要分为三类：线绕功率电阻，膜式功率电阻，实心陶瓷电阻；——应用于为大电源电路提供假负载，检测电源输出能力。 高压型：能够承受瞬间的高温、高压冲击，通常用于高压装置中，功率可达100W，额定电压可达100kV，标称值可达lGΩ；通常由玻璃釉膜和合成炭膜制成；——应用于高压装置中用作分压器和吸收器，也可供整流滤波电容器的放电和熄弧用。 高频型：自身电感量非常小，常被称为无感电阻，阻值一般小于1KΩ，功率范围宽，最大可达1W；在射频和微波电路中应用的主要是薄膜贴片式电阻 （2）按特殊用途分类，这些器件对外呈现电阻的特性，但不属于一般电阻的应用： 热敏电阻：一种传感器电阻，其电阻值随着温度的变化而改变；分为NTC（负温度系数）和PTC（正温度系数）；——主要应用于对外通信接口的电路防护（例如：POTS），温度监测等； 压敏电阻：具有非线性伏安特性的电阻器件，主要用于在电路承受过压时进行电压钳位（电源电路防护），吸收多余的电流以保护敏感器件（VDR）； 光敏电阻：利用半导体光电效应制成的一种电阻值随入射光强弱而改变的电阻器；——主要用于光控调光，光控开关等； 力敏电阻：利用半导体材料的压力电阻效应制成的，能将机械力转换为电信号的特殊元件（即电阻值随外加力大小而改变）； ——用于各种矩力计、半导体传声器及各种压力传感器中。 磁敏电阻：一种对磁敏感、具有磁阻效应（利用半导体的磁阻效应制造的，常用InSb材料加工而成）的电阻元件；——阻值随穿过其磁通量密度的变化而变化，用于磁场强度、漏磁、制磁的检测。 湿敏电阻：利用湿敏材料吸收空气中的水分而导致本身电阻值发生变化这一原理而制成。——基片上覆盖一层用感湿材料制成的膜，当空气中的水蒸气吸附在感湿膜上时，元件的电阻率和电阻值都发生变化，利用这一特性测量湿度。 气敏电阻： 一种半导体敏感器件，利用气体的吸附而使半导体本身的电导率发生变化的机理来进行检测。 5，片状电阻器​ 大多数字电路设计中使用的是片状电阻，它有非常明显的优点，足以在大多数硬件电路设计中成为“理想”电阻器：外观尺寸均匀且小型化（寄生电容、电感小），耐潮湿，耐高温（环境适应性好），可靠度高，精度高且温度系数与阻值公差小等等。 ​ 片状电阻器按生产工艺，可分为：厚膜（Thick Film）和薄膜（Thin Film）两种。 （1）薄膜电阻器的特点如下所示： 材料相对更均匀（便于电阻值的设计），制造工艺更加可控，它还可以通过光刻或者激光修正，产生图案增加电阻路径并校准电阻值，所以薄膜电阻阻值可以做到0.1%甚至0.01%； 可选用非常低温度系数（TCR）的导电材料，使得电阻器阻值随温度变化非常小，阻值稳定可靠； 一般应用于精密应用：各类仪器仪表，医疗器械，电源，电力设备，电子数码产品等。 （2）厚膜电阻器的特点如下所示： 厚膜电阻通过合金导电材料和绝缘体材料混合的糊状物质，印刷到陶瓷基板上烧制而成；其烧制成后的导电材料类似玻璃，难于切割控制阻值；所以厚膜电阻一般精度较差：10%，5%，1%是常见精度； 厚膜电阻导电材料为粑状物质，其温度系数(TCR)上很难控制，一般较大；——TCR（ppm&#x2F;℃）是一个不容忽视的微小参数，1%的普通电阻的TCR系数在几千ppm&#x2F;°C范围内，整体阻值的变化与电阻的材料、实际功率以及物理尺寸相关。 但是厚膜电阻成本非常低，迄今为止电气和电子设备中使用最多的电阻器。 ——单板上常用的0402&#x2F;0603&#x2F;0805&#x2F;1206等封装贴片电阻器，一般都是厚膜电阻 （3）薄膜电阻与厚膜电阻对比 薄膜电阻器相对于厚膜电阻器的电阻层更加均匀，容易制作高精度、稳定的电阻； 薄膜电阻器的电阻层有其最佳厚度的要求，如果薄膜电阻的电阻层太薄则更容易被氧化，并严重影响其温度系数（TCR）；——薄膜电阻器对电阻层厚度的要求严重影响了薄膜电阻的阻值范围，且大阻值薄膜电阻的退化率也非常高。 厚膜电阻依靠玻璃基体中金属粒子间的接触形成电阻，这些触点构成完整电阻；——工作中的热应变会中断接触，阻值会随着时间和温度持续增加，其稳定性较差。 厚膜电阻结构中成串的电荷运动，粒状结构使厚膜电阻产生较高的电流噪声，相同尺寸下，电阻值越高（金属成分越少），噪声越高，稳定性越差；——因为厚膜电阻中的自由电子受到电场力的作用下，在运动过程中碰撞的概率（杂质颗粒多）远大于薄膜电阻，所以电子运动更加杂乱，噪声更大。 厚膜电阻结构中的玻璃成分在电阻加工过程中形成玻璃相保护层，因此厚膜电阻的抗湿性高于薄膜电阻，更不容易被氧化。 ​ 薄膜电阻一般是作为精密型电阻和高频型电阻的选择。而厚膜电阻器价格便宜，小型化，寄生电感&#x2F;电容相对小，足以满足一般的数字电路硬件设计中对于电阻器的要求。 6，金属膜电阻器​ 金属箔电阻器的各个方面表现来看，它都是目前最接近完美的电阻器，或则说是在众多电阻器中最像“电阻器”的电阻器，是理想的精密电阻器。 ​ 金属箔电阻：通过真空熔炼形成镍铬合金，然后通过滚碾的方式制作成金属箔，再将金属箔黏合在氧化铝陶瓷基底上，再通过光刻工艺来控制金属箔的形状，从而控制电阻大小的电阻器。 特点： 高精度：调阻分辨率可达0.0005%（5ppm）； 低功率系数（PCR）：对电阻施加额定功率，阻值变化单位为ppm&#x2F;W； 低TCR：极低温度漂移（0.2ppm&#x2F;c）； 高负载寿命稳定性：50ppm； 低噪声：金属箔电阻器产生的噪音最小，电流通过金属合金的内部微粒边界导通电路；微粒间的电流路径经过一个或者更多的金属晶体包括多层，更长的路径穿过分界线，减少了噪音产生的几率； 低寄生电感&#x2F;电容： 在平面形电阻中，电阻路径图案有意设计成为平行的几何直线以抵消电抗：蛇形平面电阻阻值路径如右下图所示 ，邻近反方向电流的互感减小了线路电感，也减小了电容。 、 7，绕线电阻器​ 绕线电阻器：是将合金（例如：镍铬&#x2F;锰铜合金）导线绕在氧化铝的陶瓷基板上，用圈圈的圈数来控制电阻值大小的电阻器；其表面通常涂有保护漆或则玻璃釉。 优点： 高精度：容差小至0.005%，可以用作精密电阻； 小电流噪声：合金材料本身是均匀、细致的晶体； 低TCR：合金材料的温度系数（TCR）很小；——铜的电阻温度系数非常大（约4000ppm&#x2F;℃），其它纯金属的电阻温度系数都非常大，只有几款金属合金温度系数小、电阻率大，才适合做线绕电阻（具体数据参考上章）。 大功率：电阻散热性能好，体积做大后外加散热器，功率能做的很高； 工作稳定、可靠性高，能承受高温工作环境（可达300℃）。 缺点： 由于采用绕线方式，所以寄生电感和电容都相对较大，不能应用于高频电路中； 相对片状电阻器更大的体积以及封装； 电阻器阻值范围受限，一般不超过100KΩ。 8，膜式电阻（1）碳膜电阻​ 碳膜电阻器：采用高温真空镀膜技术将碳紧密附在瓷棒表面形成碳膜，然后加适当接头切割，并在其表面涂上环氧树脂密封保护而成的，通过碳膜的厚度和碳浓度可以控制电阻的大小。 特点： 工艺相对碳合成电阻（采用碳棒）更加复杂一点，精度更高：±5%，±2%；——为了更加精确的控制电阻，在碳膜上加工出螺旋沟槽，螺旋越多电阻越大；最后加金属引线，树脂封装成型。 阻值范围广（2.1Ω~10MΩ）、极限电压较高、功率范围宽（可达10W）； 有极好的长期稳定性，电压的改变对阻值的影响极小，且具有负温度系数； 电阻原料价格低，制作容易，生产成本低，碳膜电阻价格便宜，但体积较大； 由于碳质材料本身的原因，温度特性相对较差。 （2）金属膜电阻器​ 金属膜电阻器：利用真空沉积技术在白陶瓷棒上形成一层镍铬合金镀膜，然后在镀膜上加工出螺旋沟槽来精确控制电阻。 优点： 精度高达0.1%（精密电阻），同时由于制造简单，可以随意的调整材料成分与镀膜厚度，电阻范围很宽（1Ω~10MΩ），可以做E192系列；——E192系列有192种数字，E192系列的电阻格误差很小，有192个基本数，有0.5%，0.2%，0.1% 共3种精度；看到这种规格的精度，就知道价格就不低了，多用于对精度有较高要求的场合。 电压稳定性好，温度特性（TCR，约100ppm&#x2F;℃）好；——采用高稳定性的特种合金作为电阻材料（翻译一下：这是合金材料本身的特性，跟其它没毛关系），经过真空加热、蒸发获得，具有较好的耐热性，各项性能稳定。 耐热性好，额定工作温度为70℃，最高工作温度达155℃； 采用高热传导瓷心，散热能力强，功率负荷大，最高可达25W； 工作频率范围宽，噪音小，可以应用于高频电路中（高频电阻）； 在相同功率下，体积相对碳膜更小，约为碳膜电阻的一半，但成本更高； 应用非常广泛，适用于交流、直流及脉冲电路。 （3）玻璃釉电阻器​ 玻璃釉电阻器：是由金属银、铑、钌等金属氧化物和玻璃釉粘合剂混合成浆料，涂复在陶瓷骨架体上，经高温烧结而成。 金属玻璃釉电阻器特点： 耐高温，耐湿性好，稳定性好； 噪声小，高频特性好； 温度系数小； 阻值范围大，阻值范围为4.7Ω~200 MΩ； 额定功率有1&#x2F;8 W、l&#x2F;4 W、l&#x2F;2 W、1 w、2 W，大功率有 500 W； 耐高压，最高电压高达50KV。 9，电阻器应用 在相同电压下，使用不同阻值的电阻器可以得到不同的电流：I &#x3D; U&#x2F;R； 在相同电流下，使用不同阻值的电阻器可以得到不同的电压：U &#x3D; I*R。 ​ 我们根据U&#x3D;I*R公式可以看到：在实际应用中电阻器必须通过其电压降或电流大小，才能体现其作用，而“电阻”特性本身并不能参与信息处理、传输、存储。 电阻器应用： 保持信号状态稳定：上&#x2F;下拉应用； 限制线路电流大小：限流应用； 调整线路信号质量（例如：匹配特征阻抗）：线路匹配应用； 电源电路中监测功耗：电流监测应用。 （1）上拉&#x2F;下拉应用​ 上拉&#x2F;下拉：是将不确定的信号通过一个电阻器钳位在高&#x2F;低电平，电阻器同时起限流作用；上&#x2F;下拉电阻器的基本原理是：提供被上下拉的电路一定的电流驱动能力。 上拉是对电路注入电流，即拉电流； 下拉是对电路输出电流，即灌电流。 ​ 电阻器的上拉&#x2F;下拉应用非常广泛，在不同硬件电路设计中，其作用也有所不同： 保证器件输入管脚状态的稳定： 边沿触发的输入管脚，如果器件内部没有内置上&#x2F;下拉电阻，需外接上&#x2F;下拉电阻器，使维持管脚不被误触发；——例如中断、复位等可能为边沿触发的重要信号，必须保证其在工作期间的状态稳定。 有些应用场合不希望出现高阻状态，可以通过上拉&#x2F;下拉电阻器的方式使处于稳定状态；——一些器件在上&#x2F;下电瞬间的输出不受控（高阻），为保证输入器件管脚的稳定，外接上&#x2F;下拉保证其正确状态；例如输入MOS管G极的信号，如果是高阻状态，则G极电荷积聚可能导致MOS管误导通。 确保端口常态时有确定电平，例如：检测低电平的输入管脚，接上拉电阻器，使其常态就为高电平（适用一般设计原则）；——端口上&#x2F;下拉的默认状态是否为管脚触发状态，取决于其应用需求，例如：单板上某个器件的启动有特定要求，初始默认要一直处于复位状态（假设低电平复位），那么其复位信号需下拉。 解决总线驱动能力不足：上拉电阻提升管脚输出拉电流，下拉电阻提升管脚输出灌电流大小；——例如，有些单片机的高电平驱动能力不足（一般器件管脚的低电平驱动电流大于高电平驱动电流），需要增加上拉电阻。 悬空输入管脚比较容易受外界的电磁干扰（天线）， 外部上&#x2F;下拉可以提高总线的抗电磁干扰能力。 ​ 2.用于输出&#x2F;输出信号电平的转换或匹配： 电平匹配：输出、输入信号不同电平之间的转换；——（1）TTL电平输出驱动CMOS电平管脚，由于高电平电压判断不同，需要上拉电阻器用于提升驱动电压； （2）不同差分电平（LVPEC,HSTL等）的共模电压有差别，采用AC耦合后再输入端电阻上&#x2F;下拉分压得到满足输入共模电压要求的电平。 用于传输线终端匹配（例：戴维南匹配）。 ​ 3.用于对CMOS结构器件输入管脚的保护： 保护CMOS结构输入管脚内的保护二极管，防止保护二极管过流损坏； ——有些器件输入管脚内置保护二极管，防止输入信号电压超出管脚允许电压范围后破坏输入管脚内部结构，上下拉电阻有一定的分流能力，利于信号电平的稳定。 COMS结构输入管脚中不用的管脚不能悬空，一般接上&#x2F;下拉电阻降低输入阻抗，提供泄荷通道，防止静电造成损坏。 ——由于CMOS结构管脚的输入阻抗非常大，积聚在管脚上的电荷不容易泄放，容易损坏输入管脚。 ​ 4.上拉电阻为OD&#x2F;OC门提供驱动电流： 根据IIC总线协议，上拉电阻的取值和I2C总线的频率及负载电容有关，电阻的大小对时序有一定影响，对信号的上升时间和下降时间也有影响； 电阻计算公式：Rmin＝{Vdd(min)-0.4V}&#x2F;3mA；Rmax &#x3D; (T&#x2F;0.874) *C。 取值原则 从节约功耗及芯片的灌电流能力考虑：电阻值应当足够大； ——电阻大，电流小，损耗小。 从确保足够的驱动电流考虑应：电阻值当足够小； ——电阻小，电流大，驱动能力大。 过大的上拉电阻阻值，可能会使边沿变平缓（例如OD&#x2F;OC门，靠上拉提供驱动电流）。 综合考虑以上三点原则，一般在数字电路的上&#x2F;下拉电阻设计中选取：1k到10k之间。 （2）限流运用 LED点灯电路：电阻器用于限制发光二极管的电流，控制发光量； 三极管&#x2F;MOS管电路，电阻用于控制三极管&#x2F;MOS管所处的工作状态。 按键、开关电路：串接电阻器用于限制电容器短路瞬间时的大电流冲击，避免电容器损坏和产生过冲脉冲； ESD防护电路：人容易触碰到的板内器件，可插拔连接器（单端信号线），面板接口（复位按键，指示灯等）等，这些位置更容易由接触而引入ESD，导致器件损坏，串接大电阻（百欧姆级别）用于ESD防护； 开关电源脉冲尖峰吸收电路（RCD）：MOS管开关瞬间存在电压尖峰，RCD电路用来吸收漏感能量，减缓电压尖峰。 （3）0Ω电阻使用 模拟地与数字地单点接地：如果将模拟地和数字地大面积直接相连，会导致数模之间的互相干扰；单点接地有很多种方式：阻、容、感（包括磁珠），单过孔，金属化机械孔等等，它们有不同的优缺点，根据实际需求进行设计； 磁珠连接：带阻限波器，抑制某一频段（高频段）的噪声，预先评估噪声频点，并选择合适磁珠； 电容连接：隔直通交流，没有直流通路，会累计电荷造成浮地； 电感连接：抑制低频段噪声干扰； 0Ω连接：相当于很窄的电流通路（类似单点接地），能够有效地限制环路电流，使噪声得到抑制。 为调试方便或电路兼容设计需求； 作跳线使用；例如：IIC控制器二选一电路； 匹配电路中参数不确定，用0Ω替代，调试后再替换； PCB布线时走线困难，用0Ω跳过； 方便调试； 用于电流回路平面不连续时的跨接： 替代跳线座&#x2F;拨码开关：使用选焊确定不同单板&#x2F;应用场景的不同配置，避免拨码开关&#x2F;跳线帽的失效风险。 （4）其它应用 降压应用：电流经过电阻器时必然会产生电压降，电阻值越大，电压降越大（U&#x3D;I*R）； 放大器的负载电阻：应用了电阻器的降压作用； 电阻器R1和R2构成一个分压器：经过这两个电阻的电流I相等。 RC滤波网络：一种特殊的分压器。 电源电流监测应用：采用精密大功率电阻（例如：金属箔电阻器）串接在电源电路上，缓启动芯片监测电阻两端电压，从而监控电源功率； 提供负载电路：一些开关电源&#x2F;LDO有最小工作负载的要求，此时在电源输出端增加并接电阻，用于提升电源模块工作的稳定性（与LDO整体传递函数有关，一般可选用电容ESR充当负载）； 传输线阻抗匹配应用：传输线阻抗匹配电阻是一种非常普遍的应用；一般分为：源端串联匹配和终端并联匹配两种，示意图如下所示。 10，电阻器失效机理 开路（主要失效）：主要失效机理为电阻膜烧毁或大面积脱落（电应力），基体断裂、引线帽与电阻体脱落（机械应力）； 阻值漂移超规范（次要失效）：电阻膜有缺陷或退化，基体有可动钠离子，保护涂层不良； 引线断裂：电阻体焊接工艺缺陷，焊点污染，引线机械应力损伤； 短路：银的迁移，电晕放电。","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"器件类","slug":"器件类","permalink":"https://lilongxin178.github.io/tags/%E5%99%A8%E4%BB%B6%E7%B1%BB/"}],"author":"工程小李"},{"title":"锁相环结构及原理探究","slug":"锁相环结构及原理探究","date":"2024-04-13T06:00:00.000Z","updated":"2024-10-22T09:05:36.862Z","comments":true,"path":"2024/04/13/锁相环结构及原理探究/","permalink":"https://lilongxin178.github.io/2024/04/13/%E9%94%81%E7%9B%B8%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"锁相环结构及原理探究一、锁相环基本工作原理及常见PLL1.1锁相环基本工作原理PLL 的起始部分是稳定晶体参考频率， XTAL。它被 R 计数器分频到较低频率。这一经分频后的频率被称为比较频率（Fcomp），并输入到鉴相器。鉴频鉴相器输出电流，其直流均值与比较频率和经 N 分频器后的输出频率的相位差成比例。这个比例常数为 KФ，它就是电荷泵能流出或吸入电流的幅度。理论上，这一项除以 2π 是正确的，但没有必要在本书所有公式中这样做，因为它会被 VCO 中带来的 2π 所抵消。所以， KФ 单位是 m A &#x2F; (2π 弧)。将鉴相器输出的直流均值电流乘以环路滤波器阻抗 Z(s)，就得到 VCO（压控振荡器）输入电压。 VCO是电压到频率的转换器，具有比例系数 KVCO 。环路滤波器是低通滤波器，通常用分离器件实现。 环路滤波器随应用而各异。 调谐电压调节 VCO的输出相位。这样 VCO 的输出相位经 N 分频后就与比较频率相位相等。因为相位是频率的积分，所以也就意味着， VCO 的输出频率经 N 分频后与比较频率相等。输出频率可由下式表达：$$F_{out}&#x3D;\\frac{N}{R}*XTAL$$ 1.2常见PLL类型第一个 PLL 集成芯片大约出现在 1965 年，是一个纯粹的模拟器件。采用一个模拟乘法器(四象限乘法器)作为鉴相器;环路滤波器用无源或者有源 RC 滤波器实现，利用大家熟知的压控振荡器 VCO产生 PLL的输出信号。今天,我们称这种类型的 PLL为“线性PLL”(LPLL)。在接下来的几年里,PLL 缓慢而稳定地转移到数字领域。大约在 1970年出现了第一个数字 PLL(DPLL),实际上,它是一个混合器件,仅仅鉴相器采用数字电路实现，即使用一个 EXOR门或者一个JK 触发器,剩下的模块仍然是模拟电路。几年以后,发明了“全数字”PLL(ADPLL)。ADPLL毫无例外地全部由数字功能模块组成，因此不包含任何无源元件,如电阻和电容等。类似滤波器,PLL 也可以用软件实现。在这种情况下,PLL 的功能不再用一些专用的硬件实现，而是用计算机程序完成。我们称这种 PLL为SPLL ​ 总结:线性PLL（LPLL）、数字PLL（DPLL)、全数字PLL（ADPLL）、程控PLL（SPLL） ​ 二、PLL各组件组成及其传递函数​ 我们把PLL分成几个子模块，分别是PD（PFD+CP）、环路滤波器（Loop Filter，LPF）、VCO和分频器Divider。首先推导各子模块的传递函数。 2.1 PD（PFD+CP）（带有电荷泵输出的鉴相器）​ PD的输入是参考时钟和反馈时钟的相位差，输出是CP的电流Icp。实际上，PLL的锁定过程中，PD并不是一个连续的模型，CP的电流仅在有相位差的时间段内会打开，因此它是一个离散的信号。但是为了简化计算，我们构建PLL线性模型中，把PD看作一个连续输出电流信号的模块。为了保证这个结论近似成立，必须要有一定的条件约束。这个条件就是：PLL环路的响应要远小于参考时钟的频率，也就是说环路带宽要小于1&#x2F;10~1&#x2F;15的参考时钟频率。 PD的函数图像如上图所示，在-2π~2π的区间内，都有相位差和Icp的线性关系，其斜率为，即PD的传递函数：$$K_{PD}&#x3D;\\frac{I_{cp}}{2\\pi}$$ 鉴相器种类总结：1.模拟乘法器鉴相 2.EXOR（异或门）鉴相 3.JK触发器鉴相 4.PFD鉴相器 PFD鉴相器： 2.2 LPF（环形滤波器）LPF是由电阻电容构成的，输入为CP的电流Icp，输出为控制VCO的电压Vctrl，传递函数Z(s)的推导比较容易。下图列出了一阶、二阶、三阶环路滤波器的电路图。 由上图可知，一阶环路滤波器的传递函数为：$$Z(s)&#x3D;\\frac{1+RC_1s}{C_1s}$$二阶环路滤波器的传递函数为：$$Z(s)&#x3D;\\frac{s+\\frac{1}{RC_1}}{C_2s(s+\\frac{1}{R(C_1|C_2))})}$$三阶环路滤波器的传递函数为：$$Z(s)&#x3D;\\frac{\\frac{1}{C_{3}s}}{\\frac{1}{C_{3}s}+R_{3}}\\times[(\\frac{1}{C_{1}s}+R)\\parallel\\frac{1}{C_{2}s}\\parallel(\\frac{1}{C_{3}s}+R_{3})]$$ 2.3 VCO&#x2F;CCO（受控振荡源） VCO是PLL的核心模块，主要分为Ring-VCO和LC-VCO两大类，有很多巧妙复杂的具体电路结构，但在PLL线性模型中，我们把它看成一个理想的积分器，其输出频率随输入电压线性变化，即： $$\\omega_{out}&#x3D;\\omega_0+K_{VCO}\\cdot V_{ctrl}$$其中斜率为Kvco。VCO的输入为LPF的输出电压Vctrl，输出为相位，上述公式两侧对时间进行积分（忽略），即： $$\\int\\omega_{out}dt&#x3D;K_{VCO}\\cdot\\int V_{ctrl}dt$$频率对时间的积分为相位，整理可得其传递函数为： $$\\frac{\\phi_{out}}{V_{ctrl}}&#x3D;\\frac{K_{VCO}}{s}$$因为 VCO是一个模拟电路,它的参数(比如$\\omega_{0}$）易受到器件偏差温度漂移和老化等问题的影响。大多数 VCO的数据中都会标明的温度系数通常是以 ppm&#x2F;C 为单位给出。 2.4 Divider（分频器） 分频器的模型比较简单，其输入为VCO的输出相位，输出为反馈时钟相位，传递函数为$$\\frac{\\phi_{div}}{\\phi_{out}}&#x3D;\\frac{1}{N}$$​ 若 VCO频率较高， 用纯 CMOS 计数器则难以处理较高频率。 为避免这种困境， 常用预分频器将 VCO频率分频到较低频率区处理。预分频器常由二的幂次方来分频，这样易于实现。常用的预分频器件有：单模、双模、四模预分频器。其中，双模预分频器最为常用。 2.5 PLL的环路增益、闭环传递函数根据我们上述推导的PLL各模块的传递函数，我们可以很容易的写出PLL的环路增益、闭环传递函数（LPF以二阶为例），分别是： 有传递函数：$$H_(s)&#x3D;K_{PD}\\cdot Z(s)\\cdot\\frac{K_{VCO}}{s}&#x3D;\\frac{K_{PD}\\cdot K_{VCO}\\cdot(s+\\frac{1}{RC_{1}})}{C_{2}s^{2}(s+\\frac{1}{R(C_{1}|C_{2}))})}$$环路增益即环路上PD、LPF、VCO和Divider传递函数的乘积： $$H_{loop}(s)&#x3D;\\frac{K_{PD}\\cdot Z(s)\\cdot K_{VCO}}{N\\cdot s}&#x3D;\\frac{K_{PD}\\cdot K_{VCO}\\cdot(s+\\frac{1}{RC_1})}{N\\cdot C_2s^2(s+\\frac{1}{R(C_1|C_2))})}$$闭环传递函数即： $$H_{close}(s)&#x3D;\\frac{H_{open}(s)}{1+H_{loop}(s)}&#x3D;\\frac{\\frac{K_{PD}\\cdot K_{VCO}}{C_{2}\\cdot}\\cdot(s+\\frac{1}{RC_{1}})}{s^{3}+\\frac{1}{R(C_{1}|C_{2})}\\cdot s^{2}+\\frac{K_{PD}\\cdot K_{VCO}}{N\\cdot C_{2}}\\cdot s+\\frac{K_{PD}\\cdot K_{VCO}}{N\\cdot R\\cdot C_{1}\\cdot C_{2}}}$$ 2.6 PLL各模块的噪声对PLL输出相位噪声的贡献输入参考时钟的输出噪声为相位噪声；PD的输出噪声为CP的电流噪声；LPF的输出噪声为Vctrl上的电压噪声；VCO的输出噪声为相位噪声；Divider的输出噪声为相位噪声。各模块的输出噪声到PLL输出端的传递函数，即各模块的输出端到PLL输出端的开环增益，除以1加环路增益，各模块的传递函数及其噪声到PLL输出端的传递函数总结如下表： 可以看出输入参考时钟、PD和Divider的噪声为低通特性，LPF的噪声为带通特性，VCO的噪声为高通特性。 值得注意的是，这里没有讨论PD的输出噪声对PLL的影响，我的理解是，因为在PLL锁定或者近似锁定的情况下，相位差占整个周期的比例很小，也就是说，每个周期内，只有很小比例的时间CP会开启并引入电流噪声，因此可以忽略。 对于不同模块引入的噪声，除了在设计上降低其本身的噪声外，也可以通过PLL系统参数的调整来抑制噪声，如下图所示。减小PLL的环路带宽，可以抑制低通的带内噪声，如输入参考时钟的噪声、CP的噪声和Divider的噪声；增大PLL的环路带宽，可以抑制高通的带外噪声，即VCO的噪声。当然，通过减小（增大）带宽，来抑制带内（带外）噪声，势必也会导致带外（带内）的噪声贡献增大。 这里有一个重要的结论：PLL的相位噪声，等于各模块输出噪声乘以其到PLL输出端的传递函数的平方加和。如下： $$\\varphi_{n,all}&#x3D;\\varphi_{n,ref}(N\\cdot\\frac{L\\left(s\\right)}{1+L\\left(s\\right)})^{2}+i_{n,rp}^{2}(\\frac{N}{K_{PD}}\\cdot\\frac{L\\left(s\\right)}{1+L\\left(s\\right)})^{2}+v_{n,ctri}^{2}(\\frac{K_{VCO}}{s}\\cdot\\frac{1}{1+L\\left(s\\right)})^{2}+\\varphi_{n,rco}(\\frac{1}{1+L\\left(s\\right)})^{2}+\\varphi_{n,div}(-N\\cdot\\frac{L\\left(s\\right)}{1+L\\left(s\\right)})^{2}$$这里有一个有意思的点，如果CP的电流噪声较大，应该如何优化呢？正常来说电流噪声与电流值成正比，因此减小Icp可以降低CP本身的电流噪声，但是可以看到，其到PLL输出端的传递函数中，Kpd在分母上，并且是平方关系，一约分的话，还有一个Icp在分母上，也就是说，尽管减小Icp降低了CP本身的电流噪声，但是却导致对PLL输出端的噪声贡献增大。正确的方法应该是增大Icp。当然，考虑到实际情况Icp打开的时间占比很短，这个噪声的贡献实际应该很小。 三、 PLL关键参数3.1 PLL参数设计时需要考虑的参数因子 1.参考(或输人)信号 $u_1(t)$2.参考信号的角频率$\\omega_{1}$3.VCO 的输出信号 $u_2(t)$4.一 输出信号的角频率 $\\omega_{2}$5.鉴相器的输出信号 $u_{\\mathrm{d}}(t)$6.环路滤波器的输出信号 $u_{\\mathrm{f}}(t)$7.相位误差 $\\theta$8.定义为信号 $u_{\\mathrm{i}}(t)$ 和信号 $u_{2}(t)$之间的相位差 重要参数（用以确定锁相环稳定性）： 1.环路带宽（应在输入频率的1&#x2F;10—1&#x2F;15左右） 2.阻尼系数 3.固有频率（自然频率） 3.2 PLL重要参数推导已知：$$H_{close}(s)&#x3D;\\frac{H_{open}(s)}{1+H_{loop}(s)}&#x3D;\\frac{\\frac{K_{PD}\\cdot K_{VCO}}{C_{2}\\cdot}\\cdot(s+\\frac{1}{RC_{1}})}{s^{3}+\\frac{1}{R(C_{1}|C_{2})}\\cdot s^{2}+\\frac{K_{PD}\\cdot K_{VCO}}{N\\cdot C_{2}}\\cdot s+\\frac{K_{PD}\\cdot K_{VCO}}{N\\cdot R\\cdot C_{1}\\cdot C_{2}}}$$将该传递函数分母写成归一化形式（电路及控制理论） 分母：$$s^{2}+2\\zeta\\omega_{\\mathrm{n}}s+\\omega_{\\mathrm{n}}^{2}$$ 所以有$$H(s)&#x3D;\\frac{2s\\zeta\\omega_\\mathrm{n}+\\omega_\\mathrm{n}^2}{s^2+2s\\zeta\\omega_\\mathrm{n}+\\omega_\\mathrm{n}^2}$$ 此时有固有频率及阻尼系数为：$$\\omega_{n}&#x3D;\\sqrt{\\frac{K_{loop}}{N}},\\xi&#x3D;\\frac{\\omega_{n}}{2\\cdot\\omega_{Z}}$$及环路带宽：$$\\omega_{3dB}&#x3D;\\omega_n\\cdot\\sqrt{a+\\sqrt{a^2+1}},a&#x3D;2\\xi^2+1-\\frac{\\omega_n\\cdot N}{K_{PD}\\cdot K_{VCO}}\\cdot(4\\xi-\\frac{\\omega_n\\cdot N}{K_{PD}\\cdot K_{VCO}})$$为保证环路的稳定和快速锁定，阻尼系数取值范围一般为0.5~1，如下图，取值过大或者过小，都会在时域上引起震荡。","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"author":"工程小李"},{"title":"LDO工作原理简单探讨","slug":"LDO工作原理简单探讨","date":"2024-01-20T06:00:00.000Z","updated":"2024-10-23T08:57:03.078Z","comments":true,"path":"2024/01/20/LDO工作原理简单探讨/","permalink":"https://lilongxin178.github.io/2024/01/20/LDO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8/","excerpt":"","text":"LDO工作原理简单探讨一、LDO介绍​ LDO英文名：low dropout regulator，低压差线性稳压器。​ 电源的分类有很多种，比如开关电源、逆变电源、交流电源等等。在移动端消费类电子产品中，常用的有DCDC电源和LDO电源两种，DCDC的优点是效率高，但是噪声大；LDO正相反，它是效率低，噪声小。​ 这两种电源具体在什么场景下使用不能一概而论，通常而言，对于噪声不太敏感的数字电路多可以优先考虑DCDC，而对于模拟电路，由于对噪声比较敏感，可以优先考虑LDO，但在大部分系统中，我们为了获得较好的电源效率以及稳定的电源系统，在进行设计时我们常常将两款电源系统进行混合使用。 二、LDO模型及工作原理探讨先列举出我们可能较为常见的一些LDO模型三极管型LDO： PMOS型LDO： NMOS型LDO： ​ 此时，我们发现三种结构大同小异，只有在管子的选择上略有不同，那么我们就将其分成两种结构（三极管结构、MOS管结构）进行分析。 三极管型原理推导：​ 我们对三极管型的结构进行剖析，首先，我们能看到由电阻R和二极管Dz组成的稳定电压源（Vref），以及R1、R2、R3组成的分压网络，以及RL所代表的输出负载电阻。那么此时三级管以及运放所组成的应该是什么呢？​ 我们回到LDO的名字上，为什么要叫低压线性稳压器，那我在此先进行简单的猜测，暂且认为LDO是线性的一种元件（暂定）。​ 那么运放在此处又是什么作用呢？有正有负，又没有反馈用的电阻，那么它是不是比较器呢，我们都知道运放开环使用就是比较器嘛。但是仔细想想，好像无法将此处的运放当作比较器来使用。运算放大器的开环增益普遍在80dB以上，并且我们在实际使用LDO时都知道我们的输出会有“纹波”，假设纹波5mV，经过分压网络后有2mV，此时运算放大器以80dB的开环增益计算，输出最高都可以达到20V。一般来说，哪怕运放输出电压轨足够高，可以令输出最高达到20V，但此时三极管或者MOS管在大部分时间是处于导通状态的，那导通了就与我们上面的假设背道而驰了，并且我们知道开关电源正因为管子做开关使用，在导通和截止两个状态变换，那此时这种状态显然也不是LDO该有的工作状态，那我就只能将运放用法进行变换。​ 那我们给它加上反馈呢?加上反馈后，我们可以得到以下结构： ​ 此处反馈所使用的是复阻抗，具体为何下文在进行解释。​ 当加入反馈后，运放便由比较器变成了误差放大器，那么此时我们就可以更简单的去分析LDO的原理了。再上一张图： ​ ​ 由于运算放大器在开环增益足够大且具有负反馈电路的工作条件下，会具有虚短的特性，所以当误差放大器在系统稳定时，有：$$VFB&#x3D;Vref$$​ 此时，误差放大器有一稳定输出Vc&#x2F;Vb，此时三极管在Vb的作用下，有：$$Ie&#x3D;Ib*β$$ 负载变化时，有两种情况：1.当负载变大时​ 负载变大时，RL变小，此时由于电流IL不变，Vout随之下降，误差放大器同相反相之间产生误差，输出Vc+∆Vc,此时三极管基极电压增加，Ib增加，Ie增加，电流增加后，由于$$Vout&#x3D;RL*IL$$​ 所以，Vout会逐渐上升直到稳定到输出值 2.当负载变小时​ 负载变小时，RL变大，此时由于电流IL不变，Vout随之上升，误差放大器同相反相之间产生误差，输出Vc-∆Vc,此时三极管基极电压下降，Ib减小，Ie减小，电流减小后，由于$$Vout&#x3D;RL*IL$$​ 所以，Vout会逐渐下降直到稳定到输出值 ​ 负载变化调整输出的过程，也可以看作电路系统反馈稳定的过程，通过反馈环路的设计以达到一个稳定的输出环境。 三极管型LDO中三极管的工作区​ 可以看到，在上述推导中进行了合理假设，并验证了假设的理论可能性。​ 三极管在上述的探讨中，Ib与Ie始终具有着倍数关系，我们知道这种状态是三极管的放大区。​ 以下是三极管的工作区特点，以及输出特性曲线，以便理解对比。 (1)截止区：三极管工作在截止状态，当发射结电压Ube小于0.6—0.7V的导通电压，发射结没有导通集电结处于反向偏置，没有放大作用。(2)放大区：三极管的发射极加正向电压，集电极加反向电压导通后，Ib控制Ic，Ic与Ib近似于线性关系，在基极加上一个小信号电流，引起集电极大的信号电流输出。(3)饱和区：当三极管的集电结电流IC增大到一定程度时，再增大Ib，Ic也不会增大，超出了放大区，进入了饱和区。饱和时，Ic最大，集电极和发射之间的内阻最小，电压Uce只有0.1V~0.3V，Uce&lt;ube，发射结和集电结均处于正向电压。三极管没有放大作用，集电极和发射极相当于短路，常与截止配合于开关电路。 三级管型LDO简单仿真 MOS管型LDO原理推导：​ MOS管型LDO与三极管型LDO的差别在于它所使用的管子不同。在结构相同的条件下，可直接替换管子进行分析。 MOS管的漏源电流工作区特性​ 在拉扎维中，对MOS管的讨论在三极管区和饱和区。 ​ 此时电流公式为：$$I_D&#x3D;\\mu\\cdot\\frac{\\epsilon_{ox}}{t_{ox}}\\cdot\\frac WL\\cdot\\left[(V_{GS}-V_{TH})\\cdot V_{DS}-\\frac12V_{DS}^2\\right]$$ ​ 此时电流公式为：$$I_D&#x3D;\\frac12\\beta\\frac W{L^{\\prime}}(V_{GS}-V_{TH})^2$$​ 由上图可以发现两个工作区的漏源电流公式只有VGS一个变量，那么从这里就可以看出MOS管的LDO原理依旧是依靠误差放大器所带来的电压变化引起功率输出级的电流变化。 MOS管型LDO中MOS管的工作区​ 从上文中的MOS管漏源电流公式以及电流输出图像，可以看出MOS管的漏源电流输出并不像三极管的电流输出机制。​ MOS管的工作区需要从VGS和VDS两个方面进行分析，MOS管型的LDO可能会工作在三极管区或者饱和区。但为了达到一个较为良好的工作环境（低压降）设计师常常将工作区设置在饱和区中，只有在特殊条件下LDO才会工作在三极管区。​ 压降小时工作在线性区，损耗由导通电阻和电流决定；压降大时工作在饱和区，损耗由压降和电流决定，工作在饱和区时，环路性能比线性区好，但压降损耗增大。​ 线性区由于其增益比饱和区小，所以环路相对较差。但在补偿的条件下现在的确已经可以控制，并正常使用。 MOS管型LDO简单仿真 三、LDO输出公式推导 ​ 如图，将mos管到输出负载电阻部分的传递函数设为H(S),再将误差放大器的反馈环的传递函数设为G(s)，那么，此时系统整体传递函数流程图为： ​ 但在该系统中，当Vin为定值时，可以暂且不以Vin为系统输入。那么我们可以看到此时Q1处MOS管三个引脚，D为Vin(定值)，S为Vout（输出），那么我们只能从G级看起，将Vc作为新的输入。​ 那么此时有新的传递函数，为： ​ 又已知：$$Vc(s)&#x3D;Verr(s)×G(s)$$​ $$Verr(s)&#x3D;Vref(s)-\\alpha Vout(s) 此处\\alpha为电阻分压系数$$​ 那么加以转换，可得到新的系统传递函数为（此处Zout可看作MOS管漏源电阻）： ​ ​ 那么，此时的闭环输出公式为：$$V_{\\mathrm{out}}(s)&#x3D;\\frac{V_{\\mathrm{ref}}(s)}{\\alpha}\\frac{G(s)H(s)}{1+G(s)H(s)}-\\frac{Z_{\\mathrm{out},0\\mathrm{l}}(s)}{1+G(s)H(s)}I_{\\mathrm{out}}(s)$$​ 显然可得，当开环增益G(s)H(s)足够大时，有公式为：$$V_{\\mathrm{out}}&#x3D;\\frac{V_{\\mathrm{ref}}}\\alpha$$","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"author":"工程小李"},{"title":"TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集","slug":"TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集","date":"2024-01-10T06:00:00.000Z","updated":"2024-02-25T12:55:24.100Z","comments":true,"path":"2024/01/10/TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集/","permalink":"https://lilongxin178.github.io/2024/01/10/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E6%9C%BAADC%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%B8%BB%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%87%87%E9%9B%86/","excerpt":"","text":"TI——C2000芯片自动代码生成及示例（二）——从机ADC采集配置及主机串口采集一、搭建从机向主机发送ADC采集数据的代码模型（1）代码模型功能​ 该代码模型先由ADC进行电压采集，再进行数据的判断。在1.65V及以上，闪烁F280049评估版上的LED5，反之闪烁LED4。 （2）添加所需模块，以及部分模块设置1.添加一个ADC模块，其参数按默认设置2.添加一个SCITransmit模块，其参数按默认设置3.添加两个CompareToConstant模块,按照下图的参数进行配置 4.添加一个Rate Transition模块 5.添加两个 Digital Output 模块（配置LED所在的GPIO进行翻转） 6.完成从机（F280049）板载程序的代码模型 ​ 最后进行下载即可。 二、通过使用SCI模块在主机（Simulink）上显示ADC模块所采集到的数据（1）主机模型功能​ 该代码模型由SCI Setup模块和SCI Receive模块进行数据的采集，并对采集回的数据进行处理对电压进行计算并输出在Scope模块上。 （2）搭建主机模型1.添加模块与参数设置(1)添加一个 Host&#x2F;SCI Setup 模块（由于从机SCI未进行设置，此处可直接使用默认设置）。PS:如果用户的C2000 LaunchPad XL实验板的串口号不是1-4，请先行将串口号修改为1-4，然后才能进行下面的工作。 (2)添加一个 Host&#x2F;SCI Receive 模块。 (3)添加一个 Gain 模块（因为电压轨为3.3V，ADC为12位为4096，故参数设为3.3&#x2F;4096） （4）主机模型 （5）进行保存，点击运行​ 可以看到开发板在接入3.3V时，LED5闪烁。当ADC引脚接入GND时，LED4闪烁。 ​ 使用上位机进行数据检测，当接入3.3V时 ​ 从结果看，SCI通信与ADC检测均无误。 附录串口号修改1.打开设备管理器 2.右击你需要修改串口号的设备，点击属性 3.在“端口设置”中选择“高级” 4.进行修改并确认","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"ADC、DAC的理论信噪比计算","slug":"ADC、DAC的理论信噪比计算","date":"2024-01-03T06:00:00.000Z","updated":"2024-10-22T09:04:46.299Z","comments":true,"path":"2024/01/03/ADC、DAC的理论信噪比计算/","permalink":"https://lilongxin178.github.io/2024/01/03/ADC%E3%80%81DAC%E7%9A%84%E7%90%86%E8%AE%BA%E4%BF%A1%E5%99%AA%E6%AF%94%E8%AE%A1%E7%AE%97/","excerpt":"","text":"ADC、DAC的理论信噪比计算一、量化噪声模型以及转换器理论信噪比公式推导​ 理想转换器对信号进行数字化时，最大误差为±½ LSB，如图的一个理想N位ADC的传递函数所示。对于任何横跨数个LSB的交流信号，其量化误差可以通过一个峰峰值幅度为q (一个LSB的权重)的非相关锯齿波形来近似计算。对该近似法还可以从另一个角度来看 待，即实际量化误差发生在±1&#x2F;2* q范围内任意一点的概率相等。虽然这种分析不是百分之百 精确，但对大多数应用是足够准确的。 ​ 有一种更详细地显示了量化误差与时间关系的图像。 ​ 同样，一个简单的锯齿波形就能提供足够准 确的分析模型。锯齿误差的计算公式如下：$$\\mathrm{e(t)&#x3D;st,-q&#x2F;2s&lt;t&lt;+q&#x2F;2s}$$​ e(t)的均方值可以表示为：$$\\overline{\\mathrm{e}^2(t)}&#x3D;\\frac{\\mathrm{s}}{\\mathrm{q}}{\\int_{-\\mathrm{q}&#x2F;2\\mathrm{s}}^{+\\mathrm{q}&#x2F;2\\mathrm{s}}(\\mathrm{s}t)}^2\\mathrm{dt}$$​ 进行简单的积分和简化可得：$$\\overline{\\mathrm{e}^2(t)}&#x3D;\\frac{\\mathrm{q}^2}{12}.$$​ 因此，均方根量化误差为：$$均方根量化噪声&#x3D;\\sqrt{\\mathrm{e}^2(t)}&#x3D;\\frac{\\mathrm{q}}{\\sqrt{12}}$$​ 锯齿误差波形产生的谐波远远超过DC至f s &#x2F;2的奈奎斯特带宽，然而，所有这些高阶谐波必 须折回(混叠)到奈奎斯特带宽并相加，产生q&#x2F;√12的均方根噪声。 ​ 量化噪声近似于高斯分布，几乎均匀地分布于从DC至 f s &#x2F;2的奈奎斯特带宽。这里假设量化噪声与输入信号不相关。在某些条件下，当采样时钟和信号通过谐波相关时，量化噪声将与输入信号相关，能量集中在信号的谐波中，但均方 根值仍然约为q&#x2F;√12。理论信噪比现在可以通过一个满量程输入正弦波来计算：$$满量程输入正弦波&#x3D;\\mathrm{v(t)&#x3D;\\frac{q2^N}2\\sin(2\\pi ft)}$$​ 因此，输入信号的均方根值为：$$满量程输入的均方根值&#x3D;\\frac{\\mathrm{q}2^{\\mathrm{N}}}{2\\sqrt{2}}$$​ 因此，理想N位转换器的均方根信噪比为：$$\\mathrm{SNR}&#x3D;20\\log_{10}\\frac{\\text{rms value of FS input}}{\\text{rms value of quantization noise}}$$ $$\\mathrm{SNR&#x3D;20\\log_{10}\\left[\\frac{q2^N&#x2F;2\\sqrt{2}}{q&#x2F;\\sqrt{12}}\\right]&#x3D;20\\log_{10}2^N+20\\log_{10}\\sqrt{\\frac32}}$$ $$\\mathrm{SNR}&#x3D;6.02\\mathrm{N}+1.76\\mathrm{dB}$$ ​ 虽然量化噪声的实际频谱相当复杂，难以分析，但推导出的简化分析对大多数应用足够准确。然而，必须再次强调，均方根量化噪声是在DC至fs&#x2F;2的完整 奈奎斯特带宽范围内进行测量。 二、峰峰值分辨率与有效分辨率​ 低带宽、高分辨率ADC的分辨率为16位或24位。但是，器件的有效位数受噪声限制，而噪声则取决于输出字速率和所用的增益设置。有些公司规定使用有效分辨率来表示该参数。 ​ 下图显示模拟输入接地时从一个Σ-Δ型ADC获得的典型直方图。理想情况下，对于这一固定的直流模拟输入，输出码应为0。但是，由于噪声影响，恒定模拟输入存在一个码字分布。此噪声包括ADC内部的热噪声和模数转换过程引起的量化噪声。 ​ 码字分布一般为高斯分布。均方根噪声是通过从该直方图产生的曲线计算出的，曲线的宽度决定均方根噪声。高斯曲线的分布是从负无穷大到正无穷大。然而，99.99%的码 字出现在6.6倍均方根噪声范围内。因此，峰峰值噪声为均方根噪声的6.6倍。 ​ 数据手册一般使用均方根噪声。噪声取决于所用的滤波器 频率和增益设置。通常，当模拟输入范围缩小时，均方根噪声也会变小。但是，由于满量程模拟输入信号也被减 小，因此有效位数降低。 ​ 假设当模拟输入范围为+2.56 V且，均方根噪声等于1.25μV。根据该数据计算信噪比：$$(20\\mathrm{log}((6.6\\times1.25\\text{E-6})&#x2F;(2.56\\times2))&#x3D;-115.85\\mathrm dB$$​ 据此计算峰峰值分辨率：$$115.85&#x3D;6.02\\mathrm{N}+1.76&#x3D;&gt;\\mathrm{N}&#x3D;(115.85-1.76)&#x2F;6.02&#x3D;19\\mathrm Bits$$​ 因此，在上述条件下，19个MSB中无闪烁位。 有些公司规定使用有效分辨率，而不是峰峰值分辨率。有效分辨率是通过均方根噪声而非峰值噪声计算出的。使用均方根噪声计算信噪比：$$(20\\mathrm{log}((1.25\\text{Е-}6)&#x2F;(2.56\\times2))&#x3D;-132.25\\mathrm dB$$​ 据此计算有效分辨率：$$\\begin{aligned}132.25&amp;&#x3D;6.02\\mathrm{N}+1.76&#x3D;&gt;\\\\\\mathrm{N}&amp;&#x3D;(132.25-1.76)&#x2F;6.02&#x3D;21.7\\mathrm Bits \\end{aligned}$$​ 因此，有效分辨率 &#x3D; 峰峰值分辨率 + 2.7位。 评估ADC时，应当认识到有效分辨率与峰峰值分辨率的计算方法 不同，有效分辨率比峰峰值分辨率大2.7位。此外，有效分辨率没 有突出闪烁位数，峰峰值分辨率则指出了不闪烁的位数，因而能 更好地表示性能。 ​ 对于一个ADC，其有效分辨率比峰峰值分辨 率高2.7位。因此，对于有效分辨率为22位的器件，其无闪烁分辨率为22 – 2.7 &#x3D; 19.3位。要了解器件对于一项应用的真正性能，必须确定所规定的是峰峰值分辨率还是有效分辨率。","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"author":"工程小李"},{"title":"TI——C2000芯片自动代码生成及示例（一）","slug":"TI——C2000芯片自动代码生成及示例（一）","date":"2023-12-23T06:00:00.000Z","updated":"2024-02-18T07:54:26.122Z","comments":true,"path":"2023/12/23/TI——C2000芯片自动代码生成及示例（一）/","permalink":"https://lilongxin178.github.io/2023/12/23/TI%E2%80%94%E2%80%94C2000%E8%8A%AF%E7%89%87%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8F%8A%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"TI——C2000芯片自动代码生成及示例（一）一、简介​ 本文在配置完代码生成环境的基础上，以TI——TMS320F280049芯片为例，介绍建立模型、生成C代码，最后将代码烧写到芯片当中的详细操作过程，以及在使用中的常见问题解决方案。 二、操作流程及配置使用（1）新建工程及模型参数设置1.打开Simulink进行新建工程。 2.点击MODELING（建模）下的Model Settings（或快捷键Ctrl+E）打开模型参数配置页面： 3.由于芯片中运行的程序为离散信号，故将求解器中的步长类型设置为定步长，求解算法为离散模式，此处可设置步长时间为0.01s。 4.在Hardware Implementation（硬件实现）当中选择硬件型号。下拉可见在C2000系列各芯片型号，此处选择280049作为配置的芯片系列。 5.在Code Generation（代码生成）的Report（报告）处勾选Create Code generation report（创建代码生成报告）和 Open report automatically（自动生成报告），代码生成的过程中将自动生成报告。（其余选项非必选项，可依据需要进行勾选） （2）搭建F280049的GPIO点灯程序​ 1.打开库浏览器 2.搜索C2000，并寻找F280049型号芯片（或者你所使用的芯片型号） 3.双击打开该模块库，可以对其外设进行图形化设计。 4.在这里我们使用的是GPIO对LED进行控制，所以，可选择GPIO将其拖至Simulink的图纸上。 5.对GPIO配置完成后，给其一不断变换的常数，使其GPIO输出电平反转。 6.保存至工作文件夹 （3）代码生成（CCS下载和Simulink直接下载）1.在模型搭建完成后，在HARDWARE界面点击Build（快捷键Ctrl+B），自动生成C代码 2.在Diagnostic Viewer中出现Build process completed successfully证明代码已自动生成。 且此时，代码生成的报告也将出现。 3.此时，如果需要进行下载，可使用两种方式（MATLAB直接下载或者CCS进行下载） 先对此处进行检查，确认该处下载器配置文件存在（若没有可以进入CCS重新配置保存，并导入此处）。 4.然后依旧在刚才的界面进行下载，使用这个按键进行下载（Simulink直接下载) 4.打开CCS导入你所在的工作文件夹为CCS工程。（CCS下载） 导入工程后，使用CCXML文件进行下载。 三、过程中遇到的问题及注意事项注意事项：​ 1.MATLAB所有文件夹不要放置在存在中文的路径中。 ​ 2.工作文件夹尽可能不要选择C盘，可能会存在某些文件由于权限不足无法打开的情况。 ​ 3.Powershell的环境变量配置。（如果在编译时出现“代码生成文件不存在”的错误，且报错信息中存在“Powershell不是内部命令也不是外部命令”的话，极大可能为此处报错） ​ 4.也可能遇到CCS导入工程失败的问题。 解决方案：​ 1、2：改变工作文件夹的位置 ​ 3.在环境变量path后添加powershell的路径（C:\\Windows\\System32\\WindowsPowerShell\\v1.0） . 4.CCS无法导入遇到下图情况： ​ （1）找到工程文件下面给的.cproject文件。​ （2）利用记事本或者能打开的工具打开，有一行文字格式为这样的注释 1&lt;tool id=&quot;xxxx&quot; name=&quot;xxx&quot; superClass=&quot;xxxxx&quot;/&gt; 删除此行。 （3)重新启动软件在此导入即可导入成功。","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"Stateflow 建模基础（1）","slug":"Stateflow 建模基础（1）","date":"2023-12-14T06:00:00.000Z","updated":"2024-02-13T04:20:32.278Z","comments":true,"path":"2023/12/14/Stateflow 建模基础（1）/","permalink":"https://lilongxin178.github.io/2023/12/14/Stateflow%20%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/","excerpt":"","text":"Stateflow基础（1）一、简介及Stateflow的特点1.简介​ Stateflow是有限状态机(Finite State Machine，FSM)的图形实现工具，它可以用于解决事件驱动系统中复杂的逻辑问题。Stateflow 通过开发 FSM 和流程图的设计环境扩展Simulink的功能，在系统中可以用图形化的工具来实现各个状态之间的迁移。​ Stateflow 图表采用图形建模的方式构建层次化的、并行工作的状态和它们之间由事件驱动的逻辑迁移关系。Stateflow 在传统状态图的基础上扩展了控制流、MATLAB 函数、图形函数、真值表、临时运算符、直接事件广播，并可以集成用户自编 C 代码，而且通过Stateflow Coder 可以为 Stateflow 状态图模型自动生成C代码。 2.特点Stateflow的主要特点如下: (1)提供层次化、可并行的、具有明确执行语义的建模语言元素，并以自然易懂的形式来描述复杂逻辑系统。 (2)使用流程图定义图形化函数，使用 MATLAB 函数进行编程操作，使用真值表完成表格形式的处理。 (3)采用临时逻辑调度状态迁移与事件 (4)支持Mealy和Moore有限状态机。 (5)可集成用户自定义输人输出变量的C代码 (6)支持向量、矩阵、总线信号和定点数据类型。 (7)可进行静态模型检查，包括病态定义的真值表。 (8)可动态检测迁移冲突、死循环、状态不一致、数据范围错误和溢出问题 (9)仿真进行中以动画显示状态图的运行并记录数据，以便于对系统的理解和调试。 (10)集成了一个调试器，采用图形化断点进行单步调试，在调试时浏览其中的数据 二、构造并运行Stateflow图（设计过零比较器）1.打开 Stateflow 编辑器​ Stateflow 编辑器是一个图形环境，用于设计状态转移图、流程图、状态转移表和真值表。 要建立周期性或连续时间 Simulink 算法的条件、基于事件和基于时间的逻辑模型，请使用 [sfnew] 函数创建一个可在 Simulink 模型中作为模块进行仿真的 Stateflow 图。在 MATLAB 命令提示符处，输入： 1sfnew rectify % 在simulink中创建一个仿真图表 Simulink 创建一个名为 rectify 的模型，其中包含一个空的 Stateflow Chart 模块。要打开 Stateflow 编辑器，请双击图模块。 要为 MATLAB 应用程序设计可重用的状态机和时序逻辑，请使用 edit 函数创建可作为 MATLAB 对象执行的独立 Stateflow 图。在 MATLAB 命令提示符处，输入： 1edit rectify.sfx % 创建图表执行作为Matlab对象 如果文件 rectify.sfx 不存在，Stateflow 编辑器将创建名为 rectify 的空图。 ​ Stateflow 编辑器的主要组件是图画布、对象选项板和符号窗格。 图画布是一个绘图区域，可以在其中通过组合状态、转移和其他图形元素来创建图。 在画布的左侧有一个对象选项板，其中显示了一组可向图中添加图形元素的工具。 在画布的右侧有一个符号窗格，您可以用它向图添加新的数据、事件和消息并解析任何未定义或未使用的符号。 PS:在构造 Stateflow 图后，您可以将其内容复制到另一个具有不同执行模式的图中。例如，您可以构造在 MATLAB 中执行的图，并将其内容复制到在 Simulink 中进行仿真的图中。 2.添加状态和转移 在对象选项板中，点击状态图标并将指针移至图画布。将出现具有默认转移的状态。要放置该状态，请点击画布上的某个位置。在文本提示中，输入状态名称 On 和状态动作 y = x。 添加另一个状态。右键点击并拖动 On 状态。蓝色图形提示可以帮助您水平或垂直对齐状态。新状态的名称变为 Off。双击该状态并将状态动作修改为 y = 0。 重新对齐两个状态并在两个状态之间的空白处停留片刻出现蓝色转移提示指示进行连接。 双击每个转移并输入适当的转移条件 x&lt;t0 或 x&gt;=t0。条件出现在方括号内。（选择添加转移表达式） 5.结果如下图： 3.解析未定义的符号​ 在执行图之前，必须定义图中使用的每个符号并指定其作用域（例如，输入数据、输出数据或局部数据）。 ​ （1）打开符号窗格。​ （2）在符号窗格中，点击解析未定义的符号 ​ （3）由于阈值 t0 在仿真过程中不会更改，因此将其作用域更改为常量数据。在类型列中，点击 t0 旁边的数据类型图标，然后选择常量数据。​ （4）设置阈值 t0 的值。在值列中，点击 t0 旁边的空白输入框，并输入值 0。​ （5）保存Stateflow 图。 4.进行仿真​ （1）要返回到 Simulink 编辑器，请在画布顶部的浏览器栏中点击 Simulink 模型的名称：rectify。如果浏览器栏不可见，请点击对象选项板顶部的隐藏&#x2F;显示资源管理器栏图标 。 ​ （2）执行以下操作以将信源添加到模型中： 从 Simulink Sources 库中，添加一个 Sine Wave (Simulink) 模块。 双击 Sine Wave 模块并将采样时间设置为 0.2。 将 Sine Wave 模块的输出连接到 Stateflow 图的输入。 将信号标记为 x。 ​ （3）添加一个示波器。 ​ （4）保存 Simulink 模型。 ​ （5）开始仿真。 ​ 可以看到此处小于0的数据被滤除了。","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Simulink建模基础（2）","slug":"Simulink建模基础（2）","date":"2023-12-12T06:00:00.000Z","updated":"2024-02-08T05:55:51.657Z","comments":true,"path":"2023/12/12/Simulink建模基础（2）/","permalink":"https://lilongxin178.github.io/2023/12/12/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/","excerpt":"","text":"Simulink建模基础（2）三、数学表达式模型搭建技巧​ 本节对公式：$$y(t)&#x3D;A*e^{-t\\over a}+{K\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau)e^{t\\over a}d\\tau+{\\beta\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$的数学表达式进行建模。 1.先将结构进行剖析分解（1）将系统划分为几个子系统$$y(t)&#x3D;Function1+Function2+Function3$$ ​ 所以，有$$Function1&#x3D;A*e^{-t\\over a}$$ $$Function2&#x3D;{K\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau)e^{t\\over a}d\\tau$$ $$Function3&#x3D;{\\beta\\over\\alpha}e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$ （2）此时再将子系统划分为各个小块。如：$$Function1&#x3D;block1+block2$$ $$Function2 &#x3D; block2 * block3 * block4$$ $$Function3&#x3D; block2 *block5 *block6$$ ​ 所以可得出$$block1&#x3D;A$$ $$block2&#x3D;e^{-t\\over a}$$ $$block3&#x3D;{K\\over\\alpha}$$ $$block4&#x3D;\\int_0^tx(\\tau)e^{t\\over a}d\\tau$$ $$block5&#x3D;{\\beta\\over\\alpha}$$ $$block6&#x3D;e^{-t\\over a}\\int_0^tx(\\tau^2)e^{t\\over a}d\\tau$$ 2.开始进行建模（1）创建上文所使用的六个模块​ 如图，先创建Function1： ​ 再创建Function2，以及Function3 （2）建立子系统 ​ 将三个子系统建立完成后： ​ （3）进行三个子系统的连接 3.模型仿真及测试（1）添加测试用例及显示设备​ 添加一个正弦信号模块作为测试用例并按默认设置。 ​ 添加一个示波器模块作为显示设备。 ​ 双击该模块，在打开后界面的左上角，点击“视图”-&gt;”配置属性”，打开下图界面。 ​ 设置完成后，为下图样式： （2）对参数进行设置​ 1.按照上文参数设置，对该建模内未定义的参数进行定义并赋值。 ​ 2.设置仿真停止时间 ​ 3.设置求解器类型（变步长）；并选择ode23的求解器。 ​ 4.进行仿真 四、Simulink仿真的各种波形显示方式1.普通示波器Scope ​ 调用方式：库浏览器中搜索Scope，拖出使用即可。 2.Dashboard Scope示波器（1）添加Dashboard Scope模块,即在模型的空白处单击选中该模型然后键人“dash”接着选中Dashboard Scope （2）连接Dashboard Scope模块即双击 Dashboard Scope模块，打开模块参数对话框接着选中需要显示的信号，这些信号将出现在模块参数对话框中。 3.仿真数据检查器（Data Inspector）​ 为了在一个页面中显示多个信号的波形，或对某个&#x2F;多个信号的多次测试进行记录，以优化模型中的参数等可使用 Data Inspector。如同时观察x(t)、y(t)、Functionl、Function2和Function3等信号。 ​ （1）右击需要的信号选择“记录所选信号” ​ （2）将所需信号全部按上述操作进行处理 ​ （3）找到已经选择的信号，再次右击打开仿真数据检查器。 ​ （4）对信号在此进行简单的归位排序，以便查看。 ​ （5）记录多次仿真结果。利用该记录功能可对比在不同参数条件下的输出波形，从而选择模型中更符合实际的参数。 4.逻辑分析仪(Logic Analyzer)。​ 对于选中的信号可以一次性将其波形显示出来，特别适用于逻辑关系比较明显的系统其操作方法为:选择 Logic Analyzer 选项即可打开逻辑分析仪对话框。","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Simulink建模基础（1）","slug":"Simulink建模基础（1）","date":"2023-12-11T06:00:00.000Z","updated":"2024-02-06T06:17:34.082Z","comments":true,"path":"2023/12/11/Simulink建模基础（1）/","permalink":"https://lilongxin178.github.io/2023/12/11/Simulink%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/","excerpt":"","text":"Simulink建模基础（1）一、简介​ Simulink是动态和嵌人式等系统的建模与仿真工具，也是模型设计的基础。对于机电航空航天、信号处理、自动控制、通信、音视频处理等众多领域，Simulink 提供了交互式可视化开发环境和可定制的模块库，对系统进行建模、仿真与调试等;并可实现与 Stateflow有限状态机的无缝连接，扩展对复杂系统的建模能力。​ 通过Simulink模块库自带的1000多个预定义模块基本上可快速地创建基于MCU器件应用的系统模型。运用层次化建模、数据管理、子系统定制等手段，即使是复杂的嵌入式MCU应用系统，也能轻松地完成简明精确的模型描述。 ​ 主要内容： ​ Simulink基本操作 Simulink模块库简介 Simulink建模新方法介绍 物理建模简介 二、Simulink基本操作2.1模块库和编辑窗口2.1.1 打开Simulink的起始页​ 在MATLAB的命令行窗口中输人Simulink指令或单击MATLAB工具栏上的Simulink图标，可打开Simulink的起始页。 2.1.2 打开模型编辑窗口​ 创建一个新的模型，首先要打开一个模型编辑窗口。可以通过单击“Simulink的起始页”上所需要的模板，这里选择空白模型(Blank Model)来打开编辑窗口。 2.1.3 打开Simulink库浏览器查看Simulink模块库中包含的子库​ 单击图3.2工具栏上的“库浏览器”图标，可查看Simulink 模块库所包含的子库。 2.2 建模示例2.2.1 有物理含义或微分方程创建模型 1.求解负载电阻R上消耗功率的数学表达式​ 根据欧姆定律，该电路的电流i可表示为：$$i&#x3D;{V_S\\over R_s+R_L}$$​ 则负载电阻R上消耗的功率为$$P&#x3D;i^2*R_L$$ 2.搭建Simulink 模型(1)模型所需模块分析​ 该模型可由3个 Constant 常数模块、1个Add 加法模块、1个 Divide 除法模块1个Product乘法模块1个Math Function 数学函数模块和1个Display 显示模块来表达。 (2)创建一个Simulink模型。​ D单击工具栏上的图标打开Simulink起始页新建一个空白的Simulink模型并另存为自己的工作文件夹中。​ 从Simulink 模块库(Commonly Used Blocks、Math Operations 和 Sinks)中添加Constant模块、Add模块、Divide模块、Math Function模块、Product 模块和 Display模块等。 (3)搭建好的模型 2.3参数设置1.在“建模”中选择“模型数据编辑器”，此时界面下方出现如下编辑器： 2.选择Parameters,选中你要定义的变量位置，点击┇按钮 3.按照下图进行数据的创建： 4.在该界面进行参数的设置 5.回到matlab中的工作区，发现新增了添加的变量，将他们全部选中，右键，另存为Matlab格式文件，保存6.进入保存好的Matlab文件，得到如图所示的配置文件。 ​ 在这里可以对每个参数的值，类型等进行修改。 7.在文件的最前方，定义每一个变量的值，然后将值赋给每一个对应变量.Value，如图所示。 8.点击运行，这样就把sumlink中的值就同步修改了，以后再修改就可以直接使用文件来修改相应变量的值了 9.选择模型属性，在回调选项中的PreLoadFcn的模型预加载中输入.m文件名,这样每次直接运行simlink文件时，会自动加载一次.m文件 2.4 模型仿真​ 先对模型中各参数进行赋值，赋值后在simulink中，点击工具栏中的开始图标进行仿真。结果如下：","categories":[{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"}],"author":"工程小李"},{"title":"Matlab2022a离线安装Embedded Coder Support Package TI C2000","slug":"Matlab2022a离线安装Embedded Coder Support Package TI C2000","date":"2023-12-10T06:00:00.000Z","updated":"2024-01-31T06:31:54.964Z","comments":true,"path":"2023/12/10/Matlab2022a离线安装Embedded Coder Support Package TI C2000/","permalink":"https://lilongxin178.github.io/2023/12/10/Matlab2022a%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Embedded%20Coder%20Support%20Package%20TI%20C2000/","excerpt":"","text":"Matlab2022a离线安装Embedded Coder Support Package TI C2000一、了解Embedded Coder Support Package TI C2000​ 德州仪器 （TI） C2000 处理器的嵌入式编码器®支持包使您能够在 TI C2000™ MCU 上运行 Simulink® 模型。Embedded Coder 会自动为您的算法和设备驱动程序模块生成 C 代码，这些代码可直接在目标硬件上运行。该支持包可用于不同控制应用（包括电机控制和电源转换）的快速原型制作和生产工作流程。 ​ 内容 从 Simulink 模型生成代码并部署到 TI C2000 硬件 用于 ADC、PWM、SPI、I2C、串行、SDFM、CAN、硬件中断、eCAP、QEP、比较器、DAC 等的设备驱动程序模块。 支持多核处理器 支持控制律加速器 （CLA） 具有处理器在环 （PIL）、监控和调谐（外部模式）、SD 卡记录和实时分析的验证功能 IQMath 的代码替换库 电机控制和功率转换应用实例 ​ 我们可以看到该工具性能十分强大，下面我们来对其进行离线安装。 二、离线安装Embedded Coder Support Package TI C20001、首先安装好R2022a，安装目录不要空格（当然别的版本使用应该也没有问题）。2、安装TI开发套件及SDK 3.下载supportsoftwaredownloader_r2022b_win64.exe4.安装并进入登录界面登录（没有的话直接去Matlab官网申请）5.选择自己安装的Matlab版本 6.选择自己需要安装的支持包 7.选择默认安装路径 8.下载完成后会自动打开以下文件夹 9.打开readme，并复制当前文件夹路径​ readme此处为Windows系统安装方式。 10.按照readme的方式进行安装​ win+r打开cmd命令行 ​ 先进入自己matlab默认安装文件夹–&gt;例如D:\\MATLAB\\R2022a\\bin\\win64 ​ 再使用readme中的名令打开supportsoftware.exe，进入安装。 11.跟着系统提示安装即可。12.安装完成后，找到MATLAB附加功能管理器， 13.选择自己需要的支持包 逐步安装即可 13.打开一个示例并生成代码 14.打开CCS进行编译 ​ 编译成功","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程","slug":"TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程","date":"2023-12-02T06:00:00.000Z","updated":"2024-01-13T13:00:44.335Z","comments":true,"path":"2023/12/02/TMS320F280049C主控的DSP入门设计（学习笔记二）  TMS280049C评估板下载设置及流程/","permalink":"https://lilongxin178.github.io/2023/12/02/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%89%20%20TMS280049C%E8%AF%84%E4%BC%B0%E6%9D%BF%E4%B8%8B%E8%BD%BD%E8%AE%BE%E7%BD%AE%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"","text":"TMS320F280049C主控的DSP入门设计（学习笔记二） TMS280049C评估板下载设置及流程一、仿真器配置​ 对于280049C，其官方的LaunchPad开发板使用了XDS110仿真器的两线调试模式，而官方的ControlCard使用的是XDS100V2仿真器，开发时需要注意区分，并分别设置。本文以采用两线制调试的XDS110仿真器为例进行设置。​ 右键点击工程名，选择New—&gt;TargetConfiguration File，File name取名任意，这里可取名为LaunchPad.ccxml，点击Finish。 ​ 点击第三步的操作，进入如下图界面，选择JTAG_2_PIN调试模式。 二、配置FLASH执行​ 当代码调试完毕后，需将代码烧录到FLASH中进行固化，使其掉电程序依旧储存在FLASH中。使DSP可以脱离仿真器运行。 1.修改至FLASH模式 然后重复与RAM中执行类似的配置，具体包括以下几步： 添加索引路径 添加数学库文件路径 启用FPU和TMU 定义_LAUNCHXL_F280049C 文件管理 2.声明_FLASH和code_start为了使程序正确的从flash启动，编程时通常有一些特殊的代码需要运行(通常TI都已经在库函数中提供)。为了确保这些代码能够正确编译，执行本步骤。 3.添加cmd文件​ 将FLASH相关的cmd加进来。 三、程序烧写与仿真1.连接仿真器（对于TMS280049C直接使用电脑供电即可） 点击View—&gt;Target Configurations,进入以下界面： 右键单击Target Configurations窗口中工程目录下的“TMS320F28035.ccxml”文件（名称是你刚才新建.ccxml文件时的名称)，并选择“Launch Selected Configuration” 、 这时CCS会自动进入Debug模式 点击快捷菜单栏的“Connect Target”按下 按钮呈现为按下状态，并且调试按钮都点亮，则仿真器连接成功 2.程序烧写 在仿真器连接成功后，点击快捷菜单栏的“Load”按钮，装载程序 在弹出的“Load Program”对话框中，点击“Browse project” 在弹出的对话框中，展开你的工程文件夹，选择“Debug”文件夹下的“xxxx.out”文件，点击“OK” 点击“Load Program”对话框的“OK” 这时出现擦写进度条，等进度条完成就烧写成功啦！ 3.在线仿真 程序烧写完成后，点击“Resume”按钮可在线运行程序 若要添加断点（即让程序运行到某处停下），在对应程序行的左侧列双击，出现小圆点即可。","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程","slug":"TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程","date":"2023-12-01T06:00:00.000Z","updated":"2024-01-12T13:02:45.048Z","comments":true,"path":"2023/12/01/TMS320F280049C主控的DSP入门设计（学习笔记一）  搭建可移植的CCS工程/","permalink":"https://lilongxin178.github.io/2023/12/01/TMS320F280049C%E4%B8%BB%E6%8E%A7%E7%9A%84DSP%E5%85%A5%E9%97%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%89%20%20%E6%90%AD%E5%BB%BA%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84CCS%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"TMS320F280049C主控的DSP入门设计（学习笔记一） 搭建可移植的CCS工程 前言​ 本篇笔记将介绍如何搭建可移植的CCS工程，以便于开发TMS320F280049C主控的DSP入门设计。本篇笔记将详细介绍如何创建CCS工程、添加源文件和库文件、配置编译选项等步骤。 一、工程文件的复制CCS新建空白工程​ 首先打开CCS软件，点击project-&gt;New CCS Project，并按照所需功能自行配置工程名、芯片等信息。 ​ 除此之外，在Project type and tool-chain中配置Output foemat为eabi（ELF） ​ 点击Finish后弹出代码编辑器如下： ​ 此时，我们所选择的工作文件夹目录下应有下列文件： 拷贝支持文件进入工程文件夹​ 首先，进入C2000Ware的默认下载文件夹，如：D:\\ti\\c2000\\C2000Ware_5_01_00_00（笔者为5.01版本，同时，本文出现的所有文件地址均为笔者自己工作环境下的地址）。并找到： ​ D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common ​ 此文件夹下为F280049的DSP支持文件，接下来对该文件夹内文件进行复制，并粘贴到工作文件夹中。 首先，将source整个文件夹复制到工作文件夹中。 再将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\source文件夹下的文件复制到现在工程文件夹下的source中 将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common中的include文件夹全部复制到工程文件夹中。 再将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\include中的所有文件复制到工作文件夹的include文件夹下 将D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\common\\cmd中的四个cmd文件复制到工程文件夹。 接下来对库函数进行复制，首先找到路径地址为D:\\ti\\c2000\\C2000Ware_5_01_00_00\\driverlib\\f28004x\\driverlib的文件夹，该文件夹中含有两个文件夹和.c、.h文件（库函数文件） 首先，对该文件夹下.h文件进行复制，并粘贴到include文件夹中。 再对.c文件进行复制，此时可以先在工作文件夹中创建文件夹“C_library”，然后将.c文件全部粘贴到该文件夹下。 最后将剩余的两个文件夹复制到工程文件夹中，到此，库文件复制完毕。 添加数学运算库及f28004x_headers_nonbios.cmd文件 找到D:\\ti\\c2000\\C2000Ware_5_01_00_00\\libraries\\math\\FPUfastRTS\\c28\\lib和D:\\ti\\ccs1250\\ccs\\tools\\compiler\\ti-cgt-c2000_22.6.1.LTS\\lib（该文件夹为下载CCS后的文件夹），将该文件夹下复制数学运算库到工程文件夹中 再对f28004x_headers_nonbios.cmd文件进行添加找到D:\\ti\\c2000\\C2000Ware_5_01_00_00\\device_support\\f28004x\\headers\\cmd文件夹，对该文件进行复制粘贴。 删除多余文件，整理库文件由于使用eabi输出，所以可将ccs中与COFF输出相关的文件都删除掉。 二 、对文件进行编辑修改​ 1.删除source文件夹f28004x_usdelay.asm文件中函数声明的下划线。这步主要是为了适应eabi输出的需要，也即函数名前不加下划线。​ 修改前： 12345678 .def _F28x_usDelay .sect &quot;.TI.ramfunc&quot; .global __F28x_usDelay_F28x_usDelay: SUB ACC,#1 BF _F28x_usDelay,GEQ ;; Loop if ACC &gt;= 0 LRETR ​ 修改后： 12345678 .def F28x_usDelay .sect &quot;.TI.ramfunc&quot; .global __F28x_usDelayF28x_usDelay: SUB ACC,#1 BF F28x_usDelay,GEQ ;; Loop if ACC &gt;= 0 LRETR ​ 2.include文件夹下的f28004x_lin.h文件需要修改一个变量名，该变量名可以任意修改，修改原因是命名重复。​ 修改前： 1bp_16 IDLE:1; ​ 修改后： 1bp_16 LIN_IDLE:1; ​ 3.include文件夹下的f28004x_globalprototypes.h和source文件夹的f28004x_sysctrl.c均需要修改IDLE函数名，该变量名可以任意修改，修改原因也是命名重复。​ 修改前： 123void IDLE(void); //（f28004x_globalprototypes.h）IDLE() //（f28004x_sysctrl.c） ​ 修改后： 123void IIDLE(void); //（f28004x_globalprototypes.h）IIDLE() //（f28004x_sysctrl.c） 三、从RAM执行程序时的软件配置​ 此时已经形成了完整的CCS工程文件夹，下面将对工程文件进行索引，而一般debug时希望工程从RAM中进行运行，所以在这里进行RAM中运行的配置。​ 首先，右键项目浏览器的项目名，打开Properties（属性栏），设置成Debug，这里名字可以任意修改。 ​ 后续添加文件路径的时候会涉及到一些缩写，这些缩写在如下位置做了定义： 添加索引路径​ 右键点击项目浏览器中的项目名，打开Properties（属性）。找到Include Options。按照下图中操作，创建相对路径。直接在对话框中输入 ${PROJECT_ROOT}&#x2F;include，表示工程文件夹中的include文件夹（绝对路径）。 添加数学库文件路径同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。加入下列路径。${PROJECT_ROOT}&#x2F;rts2800_fpu32_eabi.lib ${PROJECT_ROOT}&#x2F;rts2800_fpu32_fast_supplement_eabi.lib 其中默认的库文件是libc.a，根据本文开头提到的官网文档，可以直接删除。 ​ 快速运行库rts2800_fpu32_fast_supplement.lib是rts2800_fpu32.lib的一个函数子集，它是对rts2800_fpu32.lib中一些函数进行重写，提高运算速度，所以添加是有次序要求，需要进行设置如下：​ Link order中添加这两个库，排序rts2800_fpu32_fast_supplement.lib在前rts2800_fpu32.lib在后 启用FPU和TMU同样右键点击项目浏览器中的项目名，打开Properties（属性）进行设置。 关于编译器–fp_mode的设置等信息可以参考文献[4]的2.3节。目前不推荐启用–idiv_support，在本工程中启用该选项会导致程序无法正确运行。 四、总结 ​ 到此，CCS的TMS320F280049C主控模板文件创建完毕。​ 下节将进行仿真器的配置以及程序下载流程。","categories":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"工程小李"},{"title":"关于负电阻的原理及应用的探究","slug":"关于负电阻的原理及应用的探究","date":"2023-11-30T02:00:00.000Z","updated":"2024-01-12T12:40:23.861Z","comments":true,"path":"2023/11/30/关于负电阻的原理及应用的探究/","permalink":"https://lilongxin178.github.io/2023/11/30/%E5%85%B3%E4%BA%8E%E8%B4%9F%E7%94%B5%E9%98%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%9A%84%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"关于负电阻的原理及应用的探究一、负电阻是什么 一般来说，电压随电流变化的情形在纯电阻电路中可使用微分电阻R进行表示：$$R&#x3D;{dV\\over dI}$$ ​ 由该图可看出，隧道二极管在A-B的阶段是符合前文所说的负微分效应的，但由于隧道二极管的该区域伏安特性并非线性所以该区域并不能称之为负电阻。 ​ 接下来，我们再对负电阻做更加细致的定义： ​ 根据欧姆定律可知电阻二端的电压和电流成正比，其电流-电压关系的图形斜率为正，且会通过原点。 ​ 那么就可推导理想负电阻其电流-电压关系的图形斜率为负，且会通过原点，因此只在图中的第二和第四象限出现。 ​ 故可对该理想负电阻进行绘制伏安特性曲线： ​ 由以上推论及实际现象定义负电阻，即可简单定义为理想的负电阻应该为伏安特性曲线为线性且为斜率为负并经过原点的一种元件。 ​ 历史以往研究时有注意到气体放电元件及一些真空管（例如负耗阻性管）会有负阻效应。不过实用且有经济效益的元件一直到固态电子技术普及后才出现。典型的负阻抗电路—负阻抗变换器—是由约翰·林维尔在1953年发明。而典型差动电阻为负值的元件—隧道二极管—则是由江崎玲于奈在1958年发明。 二、实际负电阻元件构建 ​ 集成电路兴起后，运算放大器由于其”虚短“”虚断“的特性，为构建一些理论中的器提供了巨大帮助，负电阻也在此应运而生。 负电阻实际元件 ​ 该图像为较为典型的负阻抗电路，其阻抗为：$$Z_i &#x3D; {V\\over A} &#x3D;-Z$$​ 现在规定图中电流电压方向为正，由于运算放大器“虚断“的性质，我们可知该电路输入阻抗的绝对值为： $$|Z|&#x3D;R_3$$​ 那再由运放的”虚短“性质可知，可以看出该电路形成了一个放大倍数为两倍的同向放大器，所以当输入端设置电压为V时，输出端电压为2V所以此时R3上的电流在我们设定的状态下应该为-A。所以此时有：$$-A&#x3D;{V\\over R}$$​ 该公式可直接推出该电路阻抗为$$Z_i &#x3D; {V\\over A} &#x3D;-Z$$​ 从本质上来看，我们会发现这里是通过改变电流方向实现的一种模拟负电阻的电路。那我们该如何验证其是否是负电阻呢？接下来进行仿真。 三、仿真验证 ​ 使用 LTspice的直流扫描分析，设置V2从0V开始到2.5V步进0.1V，并给负电阻并联一个正电阻，那么由叠加定理可知，在理想电流源的情况下，正电阻与负电阻上所经过的电流应当相反。那么，开始仿真，测量两个电阻上所经过的电流。 ​ 由测试直流分析可以看出，正电阻与负电阻的电流相反，且电流绝对值都为线性上升，所以，在该理想状态下，负电阻能够完美符合我们在前文中的标准。 四、负电阻应用场景4.1 负阻抗缓冲器​ 实际使用运算放大器时，我们往往会遇到运放驱动能力不足的情况，这种情况下，我们总是达不到我们所期望的电路效果。通常，当我们遇到这种情况时，我们通常使用一级跟随器（单位增益缓冲）。在这里我们可以尝试使用另外一种方式，即负阻抗缓冲器。当负载阻抗较小时，我们可以通过计算在输出端并联一负阻抗，此时输出阻抗趋于∞，且电路输出信号不会出现衰减的情况。​ 与传统跟随器方案相比，该方案具有一重要优点，其使负载阻抗变得很大，几乎消除了负载电阻对电路的影响。 4.2 高输入阻抗放大电路​ 在进行运放电路的使用时，我们知道同相放大器具有输入阻抗高的特点，而反相放大器具有运放输入端虚地，电路工作稳定的特定。所以，我们是否能通过负阻抗缓冲器的原理类比出高阻抗的反向放大电路呢？答案是可以实现的，通过反向在输入端并联负阻抗电路，即可有效提高输入阻抗。设计方案如下： 4.3 负电阻在LC振荡电路中的应用​ RLC二阶电路的响应具有振荡的特性,特别地,当R &#x3D; 0 时,电路的响应为无阻尼振荡。为了得到无阻尼振荡特性,可用负电阻来“中和”电路中的正电阻。 ​ 通过修改R4，可观察输出端波形幅值的衰减、稳定、增长的现象。 ​ 仿真文件地址：img&#x2F;负阻抗LC振荡仿真.ms14 at master · LILONGXIN178&#x2F;img (github.com)","categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"}],"tags":[{"name":"运放的运用","slug":"运放的运用","permalink":"https://lilongxin178.github.io/tags/%E8%BF%90%E6%94%BE%E7%9A%84%E8%BF%90%E7%94%A8/"}],"author":"工程小李"},{"title":"基于Typora的Markdown使用","slug":"基于Typora的Markdown使用","date":"2023-11-26T04:00:00.000Z","updated":"2024-01-12T12:40:40.399Z","comments":true,"path":"2023/11/26/基于Typora的Markdown使用/","permalink":"https://lilongxin178.github.io/2023/11/26/%E5%9F%BA%E4%BA%8ETypora%E7%9A%84Markdown%E4%BD%BF%E7%94%A8/","excerpt":"","text":"基于Typora的Markdown使用 一、简介 ​ Word文件是目前我们日常生活中较为常用的文字文件，但我们会发现我们在使用中经常出现排版变化的问题。那为了将排版进行统一规范，我们可能需要一种统一的软件或者文件格式来进行规范。 ​ 那我们会发现，有这样的一种标记语言——Markdown。 ​ 那么既然我们想要去使用Markdown进行文件的书写，我们自然需要一个编辑器工具对其进行编辑使用。学习之初，有我的学长向我推荐了Typora这款编辑器，而我本人也对这款编辑器较为熟悉，所以，本篇博文将基于Typora对Markdown的使用进行探讨。 二、Typora的快捷键设置 2.1 常用快捷键 加粗： Ctrl + B 撤销： Ctrl + Z 字体倾斜 ：Ctrl+I 下划线：Ctrl+U 多级标题： Ctrl + 1~6 有序列表：Ctrl + Shift + [ 无序列表：Ctrl + Shift + ] 降级快捷键 ：Tab 升级快捷键：Shift + Tab 插入链接： Ctrl + K 插入公式： Ctrl + Shift + M 行内代码： Ctrl + Shift + K 插入图片： Ctrl + Shift + I 返回Typora顶部：Ctrl+Home 返回Typora底部 ：Ctrl+End 创建表格 ：Ctrl+T 选中某句话 ：Ctrl+L 选中某个单词 ：Ctrl+D 选中相同格式的文字 ：Ctrl+E 搜索: Ctrl+F 搜索并替换 ：Ctrl+H 删除线 ：Alt+Shift+5 引用 ：Ctrl+Shift+Q 生成目录：[TOC]+Enter 2.2 部分功能演示&#x2F;介绍2.2.1 目录​ 输入[TOC]加Enter生成目录。该目录可随用户使用时自动更新，并且具有跳转功能，使用较为简单。 2.2.2 段落​ 使用换行键[Enter]可以建立新的一行,而使用Shift+Enter可以创建一个比段落间距更小的行间距。 2.2.3 代码块​ 使用快捷键Ctrl + Shift + K，创建代码块。示例如下： 1print(&quot;hello,python!&quot;&quot;) 2.2.4 数学公式打开Typora选择数学模块 点击“段落”—&gt;“公式块”（不推荐） 快捷键Ctrl+Shift+m (快捷方式) “$$”+回车 （Markdown语法） 以上三种方式都能打开数学公式的编辑栏。 示例： 2.2.5 上下标及高亮使用​ 进入偏好设置： ​ 勾选以上的拓展语法，并进行使用。 三、Typora图床设置 ​ 使用Typora时如果不使用图床，我们插入的图片将会保存至本地，那么当我们发往博客或CSDN时就无法直接显示图片。因此我们需要设置一个图床，将图片上传至图床。这里我们可以使用PicGo+Gitee的方式，无需任何费用且上传速度也不错，唯一缺点就是上传再Gitee上私密性不强。 3.1 Gitee使用及配置​ Gitee和GitHub都是较为常用的代码托管平台，和GitHub相比最大的都是就是其访问速度在国内环境下相对较快。所以我们将我们的图床远程仓库设置在Gitee上。​ Gitee地址：*https://gitee.com/* 新建仓库： ​ 此处仓库名自己可任意填写。下面两个标出的红色框中的信息直接按照图中所示配置。 创建私人令牌： ​ 回到主页，然后点击自己的头像，选择账号设置。 ​ 打开后，找到私人令牌 ​ 进入后点击生成新令牌 ​ 简单对项目进行简述，并勾选图中所勾选选项。并输入密码进行验证。 ​ 将私人令牌的token进行复制保存。 3.2 Picgo安装下载及使用​ PicGo是一款开源免费且支持多平台。 ​ 下载并打开Picgo进行安装。安装完成后进入主界面。 ​ 此处可以选择链接格式（markdown、HTML、URL、UBB、Custom等），另外也需要对图床进行设置，为了使用Gitee作为图床，我们应当先进入插件设置来添加Gitee。 下面在图床设置中对Gitee进行配置。 3.3 Typora设置​ 进入Typora，打开“文件”进入“偏好设置” ​ 在该设置中选择其用以下几种功能，并将上传服务选择为Picgo（app），并将应用程序地址填入绝对路径。 ​ 现在只要我们在typora中粘贴任意一张图片，Gicgo就会自动将图片上传到我们的gitee仓库中，肥肠的方便好用。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://lilongxin178.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lilongxin178.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://lilongxin178.github.io/tags/Typora/"}],"author":"工程小李"}],"categories":[{"name":"硬件探讨","slug":"硬件探讨","permalink":"https://lilongxin178.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8E%A2%E8%AE%A8/"},{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/categories/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/categories/MATLAB%E5%AD%A6%E4%B9%A0/"},{"name":"工具使用","slug":"工具使用","permalink":"https://lilongxin178.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://lilongxin178.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"器件类","slug":"器件类","permalink":"https://lilongxin178.github.io/tags/%E5%99%A8%E4%BB%B6%E7%B1%BB/"},{"name":"DSP设计","slug":"DSP设计","permalink":"https://lilongxin178.github.io/tags/DSP%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"https://lilongxin178.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MATLAB学习","slug":"MATLAB学习","permalink":"https://lilongxin178.github.io/tags/MATLAB%E5%AD%A6%E4%B9%A0/"},{"name":"运放的运用","slug":"运放的运用","permalink":"https://lilongxin178.github.io/tags/%E8%BF%90%E6%94%BE%E7%9A%84%E8%BF%90%E7%94%A8/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lilongxin178.github.io/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://lilongxin178.github.io/tags/Typora/"}]}